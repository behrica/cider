[{:doc-fragments
 [{:type "text", :content "The "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text",
   :content
   " class represents character strings. All\nstring literals in Java programs, such as "}
  {:type "html", :content "<pre>\"abc\"</pre> "}
  {:type "text",
   :content
   ", are\nimplemented as instances of this class.\n\nStrings are constant; their values cannot be changed after they\nare created. String buffers support mutable strings.\nBecause String objects are immutable they can be shared. For example:\n"}
  {:type "html",
   :content
   "<blockquote> <pre> \n     String str = \"abc\";\n  </pre> </blockquote>"}
  {:type "text", :content "\n\nis equivalent to:\n"}
  {:type "html",
   :content
   "<blockquote> <pre> \n     char data[] = {'a', 'b', 'c'};\n     String str = new String(data);\n  </pre> </blockquote>"}
  {:type "text",
   :content
   "\n\nHere are some more examples of how strings can be used:\n"}
  {:type "html",
   :content
   "<blockquote> <pre> \n     System.out.println(\"abc\");\n     String cde = \"cde\";\n     System.out.println(\"abc\" + cde);\n     String c = \"abc\".substring(2, 3);\n     String d = cde.substring(1, 2);\n  </pre> </blockquote>"}
  {:type "text", :content "\n\nThe class "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text",
   :content
   " includes methods for examining\nindividual characters of the sequence, for comparing strings, for\nsearching strings, for extracting substrings, and for creating a\ncopy of a string with all characters translated to uppercase or to\nlowercase. Case mapping is based on the Unicode Standard version\nspecified by the "}
  {:type "html", :content "<pre>java.lang.Character</pre> "}
  {:type "text",
   :content
   " class.\n\nThe Java language provides special support for the string\nconcatenation operator ("}
  {:type "html", :content "&nbsp;"}
  {:type "text", :content "+"}
  {:type "html", :content "&nbsp;"}
  {:type "text",
   :content
   "), and for conversion of\nother objects to strings. For additional information on string\nconcatenation and conversion, see "}
  {:type "html", :content "<i> The Java Language Specification </i>"}
  {:type "text", :content ".\n\nUnless otherwise noted, passing a "}
  {:type "html", :content "<pre>null</pre> "}
  {:type "text",
   :content
   " argument to a constructor\nor method in this class will cause a "}
  {:type "html", :content "<pre>NullPointerException</pre> "}
  {:type "text", :content " to be\nthrown.\n\nA "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text",
   :content " represents a string in the UTF-16 format\nin which "}
  {:type "html", :content "<em> supplementary characters </em>"}
  {:type "text", :content " are represented by "}
  {:type "html", :content "<em> surrogate\n pairs </em>"}
  {:type "text", :content " (see the section "}
  {:type "html",
   :content "<pre> Unicode\n Character Representations </pre>"}
  {:type "text", :content " in the "}
  {:type "html", :content "<pre>Character</pre> "}
  {:type "text",
   :content " class for\nmore information).\nIndex values refer to "}
  {:type "html", :content "<pre>char</pre> "}
  {:type "text",
   :content
   " code units, so a supplementary\ncharacter uses two positions in a "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text", :content ".\n\nThe "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text",
   :content
   " class provides methods for dealing with\nUnicode code points (i.e., characters), in addition to those for\ndealing with Unicode code units (i.e., "}
  {:type "html", :content "<pre>char</pre> "}
  {:type "text",
   :content
   " values).\n\nUnless otherwise noted, methods for comparing Strings do not take locale\ninto account.  The "}
  {:type "html", :content "<pre>java.text.Collator</pre> "}
  {:type "text",
   :content
   " class provides methods for\nfiner-grain, locale-sensitive String comparison."}],
 :doc-first-sentence-fragments
 [{:type "text", :content "The "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text", :content " class represents character strings."}],
 :doc-block-tags-fragments []}

{:doc-fragments
 [{:type "text", :content "Equivalent to "}
  {:type "html", :content "<pre>#valueOf(char[])</pre> "}
  {:type "text", :content "."}],
 :doc-first-sentence-fragments
 [{:type "text", :content "Equivalent to "}
  {:type "html", :content "<pre>#valueOf(char[])</pre> "}
  {:type "text", :content "."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>data</pre>:&nbsp;"}
  {:type "text", :content "the character array.\n\n"}
  {:type "html", :content "<i>Returns</i>:&nbsp;"}
  {:type "text", :content "a "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text",
   :content " that contains the characters of the\ncharacter array."}]}

{:doc-fragments
 [{:type "text", :content "Equivalent to "}
  {:type "html", :content "<pre>#valueOf(char[], int, int)</pre> "}
  {:type "text", :content "."}],
 :doc-first-sentence-fragments
 [{:type "text", :content "Equivalent to "}
  {:type "html", :content "<pre>#valueOf(char[], int, int)</pre> "}
  {:type "text", :content "."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>data</pre>:&nbsp;"}
  {:type "text", :content "the character array.\n\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>offset</pre>:&nbsp;"}
  {:type "text", :content "initial offset of the subarray.\n\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>count</pre>:&nbsp;"}
  {:type "text", :content "length of the subarray.\n\n"}
  {:type "html", :content "<i>Returns</i>:&nbsp;"}
  {:type "text", :content "a "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text",
   :content
   " that contains the characters of the\nspecified subarray of the character array.\n\n"}
  {:type "html",
   :content
   "<i>Throws</i>:&nbsp;<pre>IndexOutOfBoundsException</pre>:&nbsp;"}
  {:type "text", :content "if "}
  {:type "html", :content "<pre>offset</pre> "}
  {:type "text", :content " is\nnegative, or "}
  {:type "html", :content "<pre>count</pre> "}
  {:type "text", :content " is negative, or\n"}
  {:type "html", :content "<pre>offset+count</pre> "}
  {:type "text", :content " is larger than\n"}
  {:type "html", :content "<pre>data.length</pre> "}
  {:type "text", :content "."}]}

{:doc-fragments
 [{:type "text",
   :content
   "use serialVersionUID from JDK 1.0.2 for interoperability"}],
 :doc-first-sentence-fragments
 [{:type "text",
   :content
   "use serialVersionUID from JDK 1.0.2 for interoperability"}],
 :doc-block-tags-fragments []}

{:doc-fragments
 [{:type "text",
   :content
   "Returns a string whose value is this string, with all leading\nand trailing "}
  {:type "html", :content "<pre>Character#isWhitespace(int)</pre> "}
  {:type "text", :content "\nremoved.\n\nIf this "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text",
   :content
   " object represents an empty string,\nor if all code points in this string are\n"}
  {:type "html", :content "<pre>Character#isWhitespace(int)</pre> "}
  {:type "text",
   :content
   ", then an empty string\nis returned.\n\nOtherwise, returns a substring of this string beginning with the first\ncode point that is not a "}
  {:type "html", :content "<pre>Character#isWhitespace(int)</pre> "}
  {:type "text",
   :content
   "\nup to and including the last code point that is not a\n"}
  {:type "html", :content "<pre>Character#isWhitespace(int)</pre> "}
  {:type "text", :content ".\n\nThis method may be used to strip\n"}
  {:type "html", :content "<pre>Character#isWhitespace(int)</pre> "}
  {:type "text",
   :content " from\nthe beginning and end of a string."}],
 :doc-first-sentence-fragments
 [{:type "text",
   :content
   "Returns a string whose value is this string, with all leading\nand trailing "}
  {:type "html", :content "<pre>Character#isWhitespace(int)</pre> "}
  {:type "text", :content "\nremoved."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html", :content "<i>Returns</i>:&nbsp;"}
  {:type "text",
   :content
   "a string whose value is this string, with all leading\nand trailing white space removed"}]}

{:doc-fragments
 [{:type "text",
   :content
   "Replaces the first substring of this string that matches the given "}
  {:type "html", :content "<pre> regular expression </pre>"}
  {:type "text",
   :content
   " with the\ngiven replacement.\n\nAn invocation of this method of the form\n"}
  {:type "html",
   :content
   "<i> str </i> <pre>.replaceFirst(</pre>  <i> regex </i> <pre>,</pre> "}
  {:type "text", :content " "}
  {:type "html", :content "<i> repl </i> <pre>)</pre> "}
  {:type "text",
   :content "\nyields exactly the same result as the expression\n\n"}
  {:type "html",
   :content
   "<blockquote> \n  <code> \n  <pre>java.util.regex.Pattern</pre>  . <pre>java.util.regex.Pattern#compile(String)</pre>  ( <i> regex </i> ). <pre>java.util.regex.Pattern#matcher(java.lang.CharSequence)</pre>  ( <i> str </i> ). <pre>java.util.regex.Matcher#replaceFirst(String)</pre>  ( <i> repl </i> )\n  </code> \n  </blockquote>"}
  {:type "text", :content "\n\nNote that backslashes ("}
  {:type "html", :content "<pre>\\</pre> "}
  {:type "text", :content ") and dollar signs ("}
  {:type "html", :content "<pre>$</pre> "}
  {:type "text",
   :content
   ") in the\nreplacement string may cause the results to be different than if it were\nbeing treated as a literal replacement string; see\n"}
  {:type "html",
   :content "<pre>java.util.regex.Matcher#replaceFirst</pre> "}
  {:type "text", :content ".\nUse "}
  {:type "html",
   :content "<pre>java.util.regex.Matcher#quoteReplacement</pre> "}
  {:type "text",
   :content
   " to suppress the special\nmeaning of these characters, if desired."}],
 :doc-first-sentence-fragments
 [{:type "text",
   :content
   "Replaces the first substring of this string that matches the given "}
  {:type "html", :content "<pre> regular expression </pre>"}
  {:type "text", :content " with the\ngiven replacement."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>regex</pre>:&nbsp;"}
  {:type "text",
   :content
   "the regular expression to which this string is to be matched\n\n"}
  {:type "html",
   :content "<i>Param</i>&nbsp;<pre>replacement</pre>:&nbsp;"}
  {:type "text",
   :content "the string to be substituted for the first match\n\n"}
  {:type "html", :content "<i>Returns</i>:&nbsp;"}
  {:type "text", :content "The resulting "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text", :content "\n"}
  {:type "html",
   :content
   "<i>Throws</i>:&nbsp;<pre>PatternSyntaxException</pre>:&nbsp;"}
  {:type "text",
   :content "if the regular expression's syntax is invalid"}]}

{:doc-fragments
 [{:type "text",
   :content
   "Returns a string whose value is the concatenation of this\nstring repeated "}
  {:type "html", :content "<pre>count</pre> "}
  {:type "text",
   :content
   " times.\n\nIf this string is empty or count is zero then the empty\nstring is returned."}],
 :doc-first-sentence-fragments
 [{:type "text",
   :content
   "Returns a string whose value is the concatenation of this\nstring repeated "}
  {:type "html", :content "<pre>count</pre> "}
  {:type "text", :content " times."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>count</pre>:&nbsp;"}
  {:type "text", :content "number of times to repeat\n\n"}
  {:type "html", :content "<i>Returns</i>:&nbsp;"}
  {:type "text",
   :content "A string composed of this string repeated\n"}
  {:type "html", :content "<pre>count</pre> "}
  {:type "text",
   :content
   " times or the empty string if this\nstring is empty or count is zero\n\n"}
  {:type "html",
   :content
   "<i>Throws</i>:&nbsp;<pre>IllegalArgumentException</pre>:&nbsp;"}
  {:type "text", :content "if the "}
  {:type "html", :content "<pre>count</pre> "}
  {:type "text", :content " is\nnegative."}]}

{:doc-fragments
 [{:type "text",
   :content
   "Returns a character sequence that is a subsequence of this sequence.\n\nAn invocation of this method of the form\n\n"}
  {:type "html",
   :content
   "<blockquote> <pre> \n str.subSequence(begin, &nbsp; end) </pre> </blockquote>"}
  {:type "text",
   :content
   "\n\nbehaves in exactly the same way as the invocation\n\n"}
  {:type "html",
   :content
   "<blockquote> <pre> \n str.substring(begin, &nbsp; end) </pre> </blockquote>"}],
 :doc-first-sentence-fragments
 [{:type "text",
   :content
   "Returns a character sequence that is a subsequence of this sequence."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html",
   :content "<i>Param</i>&nbsp;<pre>beginIndex</pre>:&nbsp;"}
  {:type "text", :content "the begin index, inclusive.\n\n"}
  {:type "html",
   :content "<i>Param</i>&nbsp;<pre>endIndex</pre>:&nbsp;"}
  {:type "text", :content "the end index, exclusive.\n\n"}
  {:type "html", :content "<i>Returns</i>:&nbsp;"}
  {:type "text", :content "the specified subsequence.\n\n"}
  {:type "html",
   :content
   "<i>Throws</i>:&nbsp;<pre>IndexOutOfBoundsException</pre>:&nbsp;"}
  {:type "text", :content "if "}
  {:type "html", :content "<pre>beginIndex</pre> "}
  {:type "text", :content " or "}
  {:type "html", :content "<pre>endIndex</pre> "}
  {:type "text", :content " is negative,\nif "}
  {:type "html", :content "<pre>endIndex</pre> "}
  {:type "text", :content " is greater than "}
  {:type "html", :content "<pre>length()</pre> "}
  {:type "text", :content ",\nor if "}
  {:type "html", :content "<pre>beginIndex</pre> "}
  {:type "text", :content " is greater than "}
  {:type "html", :content "<pre>endIndex</pre> "}]}

{:doc-fragments
 [{:type "text",
   :content
   "Returns a string whose value is this string, with all leading\nand trailing space removed, where space is defined\nas any character whose codepoint is less than or equal to\n"}
  {:type "html", :content "<pre>'U+0020'</pre> "}
  {:type "text", :content " (the space character).\n\nIf this "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text",
   :content
   " object represents an empty character\nsequence, or the first and last characters of character sequence\nrepresented by this "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text",
   :content
   " object both have codes\nthat are not space (as defined above), then a\nreference to this "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text",
   :content
   " object is returned.\n\nOtherwise, if all characters in this string are space (as\ndefined above), then a "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text",
   :content
   " object representing an\nempty string is returned.\n\nOtherwise, let "}
  {:type "html", :content "<i> k </i>"}
  {:type "text",
   :content
   " be the index of the first character in the\nstring whose code is not a space (as defined above) and let\n"}
  {:type "html", :content "<i> m </i>"}
  {:type "text",
   :content
   " be the index of the last character in the string whose code\nis not a space (as defined above). A "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text",
   :content
   "\nobject is returned, representing the substring of this string that\nbegins with the character at index "}
  {:type "html", :content "<i> k </i>"}
  {:type "text", :content " and ends with the\ncharacter at index "}
  {:type "html", :content "<i> m </i>"}
  {:type "text", :content "-that is, the result of\n"}
  {:type "html", :content "<pre>this.substring(k, m + 1)</pre> "}
  {:type "text",
   :content
   ".\n\nThis method may be used to trim space (as defined above) from\nthe beginning and end of a string."}],
 :doc-first-sentence-fragments
 [{:type "text",
   :content
   "Returns a string whose value is this string, with all leading\nand trailing space removed, where space is defined\nas any character whose codepoint is less than or equal to\n"}
  {:type "html", :content "<pre>'U+0020'</pre> "}
  {:type "text", :content " (the space character)."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html", :content "<i>Returns</i>:&nbsp;"}
  {:type "text",
   :content
   "a string whose value is this string, with all leading\nand trailing space removed, or this string if it\nhas no leading or trailing space."}]}

{:doc-fragments
 [{:type "text",
   :content
   "Returns a string whose value is this string, with all leading\n"}
  {:type "html", :content "<pre>Character#isWhitespace(int)</pre> "}
  {:type "text", :content " removed.\n\nIf this "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text",
   :content
   " object represents an empty string,\nor if all code points in this string are\n"}
  {:type "html", :content "<pre>Character#isWhitespace(int)</pre> "}
  {:type "text",
   :content
   ", then an empty string\nis returned.\n\nOtherwise, returns a substring of this string beginning with the first\ncode point that is not a "}
  {:type "html", :content "<pre>Character#isWhitespace(int)</pre> "}
  {:type "text",
   :content
   "\nup to and including the last code point of this string.\n\nThis method may be used to trim\n"}
  {:type "html", :content "<pre>Character#isWhitespace(int)</pre> "}
  {:type "text", :content " from\nthe beginning of a string."}],
 :doc-first-sentence-fragments
 [{:type "text",
   :content
   "Returns a string whose value is this string, with all leading\n"}
  {:type "html", :content "<pre>Character#isWhitespace(int)</pre> "}
  {:type "text", :content " removed."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html", :content "<i>Returns</i>:&nbsp;"}
  {:type "text",
   :content
   "a string whose value is this string, with all leading white\nspace removed"}]}

{:doc-fragments
 [{:type "text",
   :content
   "Returns the length of this string.\nThe length is equal to the number of "}
  {:type "html", :content "<pre> Unicode\n code units </pre>"}
  {:type "text", :content " in the string."}],
 :doc-first-sentence-fragments
 [{:type "text", :content "Returns the length of this string."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html", :content "<i>Returns</i>:&nbsp;"}
  {:type "text",
   :content
   "the length of the sequence of characters represented by this\nobject."}]}

{:doc-fragments
 [{:type "text",
   :content "Tests if this string ends with the specified suffix."}],
 :doc-first-sentence-fragments
 [{:type "text",
   :content "Tests if this string ends with the specified suffix."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>suffix</pre>:&nbsp;"}
  {:type "text", :content "the suffix.\n\n"}
  {:type "html", :content "<i>Returns</i>:&nbsp; <pre>true</pre> "}
  {:type "text",
   :content
   " if the character sequence represented by the\nargument is a suffix of the character sequence represented by\nthis object; "}
  {:type "html", :content "<pre>false</pre> "}
  {:type "text", :content " otherwise. Note that the\nresult will be "}
  {:type "html", :content "<pre>true</pre> "}
  {:type "text",
   :content
   " if the argument is the\nempty string or is equal to this "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text", :content " object\nas determined by the "}
  {:type "html", :content "<pre>#equals(Object)</pre> "}
  {:type "text", :content " method."}]}

{:doc-fragments
 [{:type "text",
   :content
   "Returns a string whose value is this string, with incidental\n"}
  {:type "html", :content "<pre>Character#isWhitespace(int)</pre> "}
  {:type "text",
   :content " removed from\nthe beginning and end of every line.\n"}
  {:type "html",
   :content
   "<p> \n Incidental  <pre>Character#isWhitespace(int)</pre>  \n is often present in a text block to align the content with the opening\n delimiter. For example, in the following code, dots represent incidental\n  <pre>Character#isWhitespace(int)</pre>  :\n  <blockquote> <pre> \n String html = \"\"\"\n .............. &lt; html &gt; \n ..............     &lt; body &gt; \n ..............         &lt; p &gt; Hello, world &lt; /p &gt; \n ..............     &lt; /body &gt; \n .............. &lt; /html &gt; \n ..............\"\"\";\n  </pre> </blockquote> \n This method treats the incidental\n  <pre>Character#isWhitespace(int)</pre>   as indentation to be\n stripped, producing a string that preserves the relative indentation of\n the content. Using | to visualize the start of each line of the string:\n  <blockquote> <pre> \n | &lt; html &gt; \n |     &lt; body &gt; \n |         &lt; p &gt; Hello, world &lt; /p &gt; \n |     &lt; /body &gt; \n | &lt; /html &gt; \n  </pre> </blockquote> \n First, the individual lines of this string are extracted. A  <i> line </i> \n is a sequence of zero or more characters followed by either a line\n terminator or the end of the string.\n If the string has at least one line terminator, the last line consists\n of the characters between the last terminator and the end of the string.\n Otherwise, if the string has no terminators, the last line is the start\n of the string to the end of the string, in other words, the entire\n string.\n A line does not include the line terminator.\n  <p> \n Then, the  <i> minimum indentation </i>  (min) is determined as follows:\n  <ul> \n    <li> <p> For each non-blank line (as defined by  <pre>String#isBlank()</pre>  ),\n   the leading  <pre>Character#isWhitespace(int)</pre>  \n   characters are counted. </p> \n    </li> \n    <li> <p> The leading  <pre>Character#isWhitespace(int)</pre>  \n   characters on the last line are also counted even if\n    <pre>String#isBlank()</pre>  . </p> \n    </li> \n  </ul> \n  <p> The  <i> min </i>  value is the smallest of these counts.\n  <p> \n For each  <pre>String#isBlank()</pre>   line,  <i> min </i>  leading\n  <pre>Character#isWhitespace(int)</pre>   characters are\n removed, and any trailing  <pre>Character#isWhitespace(int)</pre>   characters are removed.  <pre>String#isBlank()</pre>   lines\n are replaced with the empty string.\n\n<p> \n Finally, the lines are joined into a new string, using the LF character\n  <pre>\"\\n\"</pre>   (U+000A) to separate lines."}],
 :doc-first-sentence-fragments
 [{:type "text",
   :content
   "Returns a string whose value is this string, with incidental\n"}
  {:type "html", :content "<pre>Character#isWhitespace(int)</pre> "}
  {:type "text",
   :content " removed from\nthe beginning and end of every line."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html", :content "<i>Returns</i>:&nbsp;"}
  {:type "text",
   :content
   "string with incidental indentation removed and line\nterminators normalized"}]}

{:doc-fragments
 [{:type "text",
   :content
   "Tests if two string regions are equal.\n\nA substring of this "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text",
   :content " object is compared to a substring\nof the argument "}
  {:type "html", :content "<pre>other</pre> "}
  {:type "text", :content ". The result is "}
  {:type "html", :content "<pre>true</pre> "}
  {:type "text",
   :content
   " if these\nsubstrings represent Unicode code point sequences that are the same,\nignoring case if and only if "}
  {:type "html", :content "<pre>ignoreCase</pre> "}
  {:type "text", :content " is true.\nThe sequences "}
  {:type "html", :content "<pre>tsequence</pre> "}
  {:type "text", :content " and "}
  {:type "html", :content "<pre>osequence</pre> "}
  {:type "text", :content " are compared,\nwhere "}
  {:type "html", :content "<pre>tsequence</pre> "}
  {:type "text",
   :content " is the sequence produced as if by calling\n"}
  {:type "html",
   :content "<pre>this.substring(toffset, len).codePoints()</pre> "}
  {:type "text", :content " and "}
  {:type "html", :content "<pre>osequence</pre> "}
  {:type "text",
   :content "\nis the sequence produced as if by calling\n"}
  {:type "html",
   :content "<pre>other.substring(ooffset, len).codePoints()</pre> "}
  {:type "text", :content ".\nThe result is "}
  {:type "html", :content "<pre>true</pre> "}
  {:type "text",
   :content " if and only if all of the following\nare true:\n"}
  {:type "html",
   :content
   "<ul> <li> <pre>toffset</pre>   is non-negative.\n  <li> <pre>ooffset</pre>   is non-negative.\n  <li> <pre>toffset+len</pre>   is less than or equal to the length of this\n  <pre>String</pre>   object.\n  <li> <pre>ooffset+len</pre>   is less than or equal to the length of the other\n argument.\n  <li> if  <pre>ignoreCase</pre>   is  <pre>false</pre>  , all pairs of corresponding Unicode\n code points are equal integer values; or if  <pre>ignoreCase</pre>   is  <pre>true</pre>  ,\n  <pre>Character#toLowerCase(int)</pre>  \n  <pre>Character#toUpperCase(int)</pre>  <pre>)</pre>   on all pairs of Unicode code points\n results in equal integer values.\n  </ul>"}
  {:type "text", :content "\n\nNote that this method does "}
  {:type "html", :content "<em> not </em>"}
  {:type "text",
   :content
   " take locale into account,\nand will result in unsatisfactory results for certain locales when\n"}
  {:type "html", :content "<pre>ignoreCase</pre> "}
  {:type "text", :content " is "}
  {:type "html", :content "<pre>true</pre> "}
  {:type "text", :content ".  The "}
  {:type "html", :content "<pre>java.text.Collator</pre> "}
  {:type "text",
   :content " class\nprovides locale-sensitive comparison."}],
 :doc-first-sentence-fragments
 [{:type "text", :content "Tests if two string regions are equal."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html",
   :content "<i>Param</i>&nbsp;<pre>ignoreCase</pre>:&nbsp;"}
  {:type "text", :content "if "}
  {:type "html", :content "<pre>true</pre> "}
  {:type "text",
   :content ", ignore case when comparing\ncharacters.\n\n"}
  {:type "html",
   :content "<i>Param</i>&nbsp;<pre>toffset</pre>:&nbsp;"}
  {:type "text",
   :content
   "the starting offset of the subregion in this\nstring.\n\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>other</pre>:&nbsp;"}
  {:type "text", :content "the string argument.\n\n"}
  {:type "html",
   :content "<i>Param</i>&nbsp;<pre>ooffset</pre>:&nbsp;"}
  {:type "text",
   :content
   "the starting offset of the subregion in the string\nargument.\n\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>len</pre>:&nbsp;"}
  {:type "text",
   :content "the number of characters (Unicode code units -\n16bit "}
  {:type "html", :content "<pre>char</pre> "}
  {:type "text", :content " value) to compare.\n\n"}
  {:type "html", :content "<i>Returns</i>:&nbsp; <pre>true</pre> "}
  {:type "text",
   :content
   " if the specified subregion of this string\nmatches the specified subregion of the string argument;\n"}
  {:type "html", :content "<pre>false</pre> "}
  {:type "text",
   :content
   " otherwise. Whether the matching is exact\nor case insensitive depends on the "}
  {:type "html", :content "<pre>ignoreCase</pre> "}
  {:type "text", :content "\nargument."}]}

{:doc-fragments
 [{:type "text",
   :content
   "Tests if two string regions are equal.\n\nA substring of this "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text",
   :content
   " object is compared to a substring\nof the argument other. The result is true if these substrings\nrepresent identical character sequences. The substring of this\n"}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text", :content " object to be compared begins at index "}
  {:type "html", :content "<pre>toffset</pre> "}
  {:type "text", :content "\nand has length "}
  {:type "html", :content "<pre>len</pre> "}
  {:type "text",
   :content
   ". The substring of other to be compared\nbegins at index "}
  {:type "html", :content "<pre>ooffset</pre> "}
  {:type "text", :content " and has length "}
  {:type "html", :content "<pre>len</pre> "}
  {:type "text", :content ". The\nresult is "}
  {:type "html", :content "<pre>false</pre> "}
  {:type "text",
   :content
   " if and only if at least one of the following\nis true:\n"}
  {:type "html",
   :content
   "<ul> <li> <pre>toffset</pre>   is negative.\n  <li> <pre>ooffset</pre>   is negative.\n  <li> <pre>toffset+len</pre>   is greater than the length of this\n  <pre>String</pre>   object.\n  <li> <pre>ooffset+len</pre>   is greater than the length of the other\n argument.\n  <li> There is some nonnegative integer  <i> k </i>  less than  <pre>len</pre>  \n such that:\n  <pre>this.charAt(toffset + </pre>  <i> k </i> <pre>) != other.charAt(ooffset + </pre>  \n  <i> k </i> <pre>)</pre>  \n  </ul>"}
  {:type "text", :content "\n\nNote that this method does "}
  {:type "html", :content "<em> not </em>"}
  {:type "text", :content " take locale into account.  The\n"}
  {:type "html", :content "<pre>java.text.Collator</pre> "}
  {:type "text",
   :content " class provides locale-sensitive comparison."}],
 :doc-first-sentence-fragments
 [{:type "text", :content "Tests if two string regions are equal."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html",
   :content "<i>Param</i>&nbsp;<pre>toffset</pre>:&nbsp;"}
  {:type "text",
   :content "the starting offset of the subregion in this string.\n\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>other</pre>:&nbsp;"}
  {:type "text", :content "the string argument.\n\n"}
  {:type "html",
   :content "<i>Param</i>&nbsp;<pre>ooffset</pre>:&nbsp;"}
  {:type "text",
   :content
   "the starting offset of the subregion in the string\nargument.\n\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>len</pre>:&nbsp;"}
  {:type "text", :content "the number of characters to compare.\n\n"}
  {:type "html", :content "<i>Returns</i>:&nbsp; <pre>true</pre> "}
  {:type "text",
   :content
   " if the specified subregion of this string\nexactly matches the specified subregion of the string argument;\n"}
  {:type "html", :content "<pre>false</pre> "}
  {:type "text", :content " otherwise."}]}

{:doc-fragments
 [{:type "text", :content "Returns a stream of "}
  {:type "html", :content "<pre>int</pre> "}
  {:type "text", :content " zero-extending the "}
  {:type "html", :content "<pre>char</pre> "}
  {:type "text",
   :content " values\nfrom this sequence.  Any char which maps to a "}
  {:type "html", :content "<pre> surrogate code\n point </pre>"}
  {:type "text", :content " is passed through uninterpreted."}],
 :doc-first-sentence-fragments
 [{:type "text", :content "Returns a stream of "}
  {:type "html", :content "<pre>int</pre> "}
  {:type "text", :content " zero-extending the "}
  {:type "html", :content "<pre>char</pre> "}
  {:type "text", :content " values\nfrom this sequence."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html", :content "<i>Returns</i>:&nbsp;"}
  {:type "text",
   :content "an IntStream of char values from this sequence"}]}

{:doc-fragments
 [{:type "text", :content "Converts all of the characters in this "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text",
   :content
   " to lower\ncase using the rules of the default locale. This is equivalent to calling\n"}
  {:type "html",
   :content "<pre>toLowerCase(Locale.getDefault())</pre> "}
  {:type "text", :content ".\n\n"}
  {:type "html", :content "<b> Note: </b>"}
  {:type "text",
   :content
   " This method is locale sensitive, and may produce unexpected\nresults if used for strings that are intended to be interpreted locale\nindependently.\nExamples are programming language identifiers, protocol keys, and HTML\ntags.\nFor instance, "}
  {:type "html", :content "<pre>\"TITLE\".toLowerCase()</pre> "}
  {:type "text", :content " in a Turkish locale\nreturns "}
  {:type "html", :content "<pre>\"t\\u0131tle\"</pre> "}
  {:type "text",
   :content
   ", where '\\u0131' is the\nLATIN SMALL LETTER DOTLESS I character.\nTo obtain correct results for locale insensitive strings, use\n"}
  {:type "html", :content "<pre>toLowerCase(Locale.ROOT)</pre> "}
  {:type "text", :content "."}],
 :doc-first-sentence-fragments
 [{:type "text", :content "Converts all of the characters in this "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text",
   :content " to lower\ncase using the rules of the default locale."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html", :content "<i>Returns</i>:&nbsp;"}
  {:type "text", :content "the "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text", :content ", converted to lowercase."}]}

{:doc-fragments
 [{:type "text", :content "Converts all of the characters in this "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text",
   :content " to lower\ncase using the rules of the given "}
  {:type "html", :content "<pre>Locale</pre> "}
  {:type "text",
   :content
   ".  Case mapping is based\non the Unicode Standard version specified by the "}
  {:type "html", :content "<pre>java.lang.Character</pre> "}
  {:type "text",
   :content
   "\nclass. Since case mappings are not always 1:1 char mappings, the resulting\n"}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text",
   :content " may be a different length than the original "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text",
   :content
   ".\n\nExamples of lowercase  mappings are in the following table:\n"}
  {:type "html",
   :content
   "<table class=\"plain\"> \n  <caption style=\"display:none\"> Lowercase mapping examples showing language code of locale, upper case, lower case, and description </caption> \n  <thead> \n  <tr> \n    <th scope=\"col\"> Language Code of Locale </th> \n    <th scope=\"col\"> Upper Case </th> \n    <th scope=\"col\"> Lower Case </th> \n    <th scope=\"col\"> Description </th> \n  </tr> \n  </thead> \n  <tbody> \n  <tr> \n    <td> tr (Turkish) </td> \n    <th scope=\"row\" style=\"font-weight:normal; text-align:left\"> &#92; u0130 </th> \n    <td> &#92; u0069 </td> \n    <td> capital letter I with dot above - &gt;  small letter i </td> \n  </tr> \n  <tr> \n    <td> tr (Turkish) </td> \n    <th scope=\"row\" style=\"font-weight:normal; text-align:left\"> &#92; u0049 </th> \n    <td> &#92; u0131 </td> \n    <td> capital letter I - &gt;  small letter dotless i  </td> \n  </tr> \n  <tr> \n    <td> (all) </td> \n    <th scope=\"row\" style=\"font-weight:normal; text-align:left\"> French Fries </th> \n    <td> french fries </td> \n    <td> lowercased all chars in String </td> \n  </tr> \n  <tr> \n    <td> (all) </td> \n    <th scope=\"row\" style=\"font-weight:normal; text-align:left\"> \n        &Iota; &Chi; &Theta; &Upsilon; &Sigma; </th> \n    <td> &iota; &chi; &theta; &upsilon; &sigma; </td> \n    <td> lowercased all chars in String </td> \n  </tr> \n  </tbody> \n  </table>"}],
 :doc-first-sentence-fragments
 [{:type "text", :content "Converts all of the characters in this "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text",
   :content " to lower\ncase using the rules of the given "}
  {:type "html", :content "<pre>Locale</pre> "}
  {:type "text", :content "."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>locale</pre>:&nbsp;"}
  {:type "text",
   :content "use the case transformation rules for this locale\n\n"}
  {:type "html", :content "<i>Returns</i>:&nbsp;"}
  {:type "text", :content "the "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text", :content ", converted to lowercase."}]}

{:doc-fragments
 [{:type "text",
   :content "Tests if this string starts with the specified prefix."}],
 :doc-first-sentence-fragments
 [{:type "text",
   :content "Tests if this string starts with the specified prefix."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>prefix</pre>:&nbsp;"}
  {:type "text", :content "the prefix.\n\n"}
  {:type "html", :content "<i>Returns</i>:&nbsp; <pre>true</pre> "}
  {:type "text",
   :content
   " if the character sequence represented by the\nargument is a prefix of the character sequence represented by\nthis string; "}
  {:type "html", :content "<pre>false</pre> "}
  {:type "text", :content " otherwise.\nNote also that "}
  {:type "html", :content "<pre>true</pre> "}
  {:type "text",
   :content
   " will be returned if the\nargument is an empty string or is equal to this\n"}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text", :content " object as determined by the\n"}
  {:type "html", :content "<pre>#equals(Object)</pre> "}
  {:type "text", :content " method."}]}

{:doc-fragments
 [{:type "text",
   :content
   "Tests if the substring of this string beginning at the\nspecified index starts with the specified prefix."}],
 :doc-first-sentence-fragments
 [{:type "text",
   :content
   "Tests if the substring of this string beginning at the\nspecified index starts with the specified prefix."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>prefix</pre>:&nbsp;"}
  {:type "text", :content "the prefix.\n\n"}
  {:type "html",
   :content "<i>Param</i>&nbsp;<pre>toffset</pre>:&nbsp;"}
  {:type "text", :content "where to begin looking in this string.\n\n"}
  {:type "html", :content "<i>Returns</i>:&nbsp; <pre>true</pre> "}
  {:type "text",
   :content
   " if the character sequence represented by the\nargument is a prefix of the substring of this object starting\nat index "}
  {:type "html", :content "<pre>toffset</pre> "}
  {:type "text", :content "; "}
  {:type "html", :content "<pre>false</pre> "}
  {:type "text", :content " otherwise.\nThe result is "}
  {:type "html", :content "<pre>false</pre> "}
  {:type "text", :content " if "}
  {:type "html", :content "<pre>toffset</pre> "}
  {:type "text",
   :content " is\nnegative or greater than the length of this\n"}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text",
   :content
   " object; otherwise the result is the same\nas the result of the expression\n"}
  {:type "html",
   :content
   "<pre> \n          this.substring(toffset).startsWith(prefix)\n           </pre>"}]}

{:doc-fragments
 [{:type "text",
   :content "Splits this string around matches of the given "}
  {:type "html", :content "<pre> regular expression </pre>"}
  {:type "text",
   :content
   ".\n\nThis method works as if by invoking the two-argument "}
  {:type "html", :content "<pre>#split(String, int)</pre> "}
  {:type "text",
   :content
   " method with the given expression and a limit\nargument of zero.  Trailing empty strings are therefore not included in\nthe resulting array.\n\nThe string "}
  {:type "html", :content "<pre>\"boo:and:foo\"</pre> "}
  {:type "text",
   :content
   ", for example, yields the following\nresults with these expressions:\n\n"}
  {:type "html",
   :content
   "<blockquote> <table class=\"plain\"> \n  <caption style=\"display:none\"> Split examples showing regex and result </caption> \n  <thead> \n  <tr> \n   <th scope=\"col\"> Regex </th> \n   <th scope=\"col\"> Result </th> \n  </tr> \n  </thead> \n  <tbody> \n  <tr> <th scope=\"row\" style=\"text-weight:normal\"> : </th> \n      <td> <pre>{ \"boo\", \"and\", \"foo\" }</pre>  </td> </tr> \n  <tr> <th scope=\"row\" style=\"text-weight:normal\"> o </th> \n      <td> <pre>{ \"b\", \"\", \":and:f\" }</pre>  </td> </tr> \n  </tbody> \n  </table> </blockquote>"}],
 :doc-first-sentence-fragments
 [{:type "text",
   :content "Splits this string around matches of the given "}
  {:type "html", :content "<pre> regular expression </pre>"}
  {:type "text", :content "."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>regex</pre>:&nbsp;"}
  {:type "text", :content "the delimiting regular expression\n\n"}
  {:type "html", :content "<i>Returns</i>:&nbsp;"}
  {:type "text",
   :content
   "the array of strings computed by splitting this string\naround matches of the given regular expression\n\n"}
  {:type "html",
   :content
   "<i>Throws</i>:&nbsp;<pre>PatternSyntaxException</pre>:&nbsp;"}
  {:type "text",
   :content "if the regular expression's syntax is invalid"}]}

{:doc-fragments
 [{:type "text",
   :content "Splits this string around matches of the given\n"}
  {:type "html", :content "<pre> regular expression </pre>"}
  {:type "text", :content ".\n\n"}
  {:type "html",
   :content
   "<p>  The array returned by this method contains each substring of this\n string that is terminated by another substring that matches the given\n expression or is terminated by the end of the string.  The substrings in\n the array are in the order in which they occur in this string.  If the\n expression does not match any part of the input then the resulting array\n has just one element, namely this string.\n\n<p>  When there is a positive-width match at the beginning of this\n string then an empty leading substring is included at the beginning\n of the resulting array. A zero-width match at the beginning however\n never produces such empty leading substring.\n\n<p>  The  <pre>limit</pre>   parameter controls the number of times the\n pattern is applied and therefore affects the length of the resulting\n array.\n  <ul> \n     <li> <p> \n    If the  <i> limit </i>  is positive then the pattern will be applied\n    at most  <i> limit </i> &nbsp; - &nbsp; 1 times, the array's length will be\n    no greater than  <i> limit </i> , and the array's last entry will contain\n    all input beyond the last matched delimiter. </p> </li>\n\n<li> <p> \n    If the  <i> limit </i>  is zero then the pattern will be applied as\n    many times as possible, the array can have any length, and trailing\n    empty strings will be discarded. </p> </li>\n\n<li> <p> \n    If the  <i> limit </i>  is negative then the pattern will be applied\n    as many times as possible and the array can have any length. </p> </li> \n  </ul>\n\n<p>  The string  <pre>\"boo:and:foo\"</pre>  , for example, yields the\n following results with these parameters:\n\n<blockquote> <table class=\"plain\"> \n  <caption style=\"display:none\"> Split example showing regex, limit, and result </caption> \n  <thead> \n  <tr> \n      <th scope=\"col\"> Regex </th> \n      <th scope=\"col\"> Limit </th> \n      <th scope=\"col\"> Result </th> \n  </tr> \n  </thead> \n  <tbody> \n  <tr> <th scope=\"row\" rowspan=\"3\" style=\"font-weight:normal\"> : </th> \n      <th scope=\"row\" style=\"font-weight:normal; text-align:right; padding-right:1em\"> 2 </th> \n      <td> <pre>{ \"boo\", \"and:foo\" }</pre>  </td> </tr> \n  <tr> <!-- : --> \n      <th scope=\"row\" style=\"font-weight:normal; text-align:right; padding-right:1em\"> 5 </th> \n      <td> <pre>{ \"boo\", \"and\", \"foo\" }</pre>  </td> </tr> \n  <tr> <!-- : --> \n      <th scope=\"row\" style=\"font-weight:normal; text-align:right; padding-right:1em\"> -2 </th> \n      <td> <pre>{ \"boo\", \"and\", \"foo\" }</pre>  </td> </tr> \n  <tr> <th scope=\"row\" rowspan=\"3\" style=\"font-weight:normal\"> o </th> \n      <th scope=\"row\" style=\"font-weight:normal; text-align:right; padding-right:1em\"> 5 </th> \n      <td> <pre>{ \"b\", \"\", \":and:f\", \"\", \"\" }</pre>  </td> </tr> \n  <tr> <!-- o --> \n      <th scope=\"row\" style=\"font-weight:normal; text-align:right; padding-right:1em\"> -2 </th> \n      <td> <pre>{ \"b\", \"\", \":and:f\", \"\", \"\" }</pre>  </td> </tr> \n  <tr> <!-- o --> \n      <th scope=\"row\" style=\"font-weight:normal; text-align:right; padding-right:1em\"> 0 </th> \n      <td> <pre>{ \"b\", \"\", \":and:f\" }</pre>  </td> </tr> \n  </tbody> \n  </table> </blockquote>\n\n<p>  An invocation of this method of the form\n  <i> str. </i> <pre>split(</pre>  <i> regex </i> <pre>,</pre>  &nbsp; <i> n </i> <pre>)</pre>  \n yields the same result as the expression\n\n<blockquote> \n  <code> \n  <pre>java.util.regex.Pattern</pre>  . <pre>java.util.regex.Pattern#compile(String)</pre>  ( <i> regex </i> ). <pre>java.util.regex.Pattern#split(java.lang.CharSequence,int)</pre>  ( <i> str </i> , &nbsp; <i> n </i> )\n  </code> \n  </blockquote>"}],
 :doc-first-sentence-fragments
 [{:type "text",
   :content "Splits this string around matches of the given\n"}
  {:type "html", :content "<pre> regular expression </pre>"}
  {:type "text", :content "."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>regex</pre>:&nbsp;"}
  {:type "text", :content "the delimiting regular expression\n\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>limit</pre>:&nbsp;"}
  {:type "text",
   :content "the result threshold, as described above\n\n"}
  {:type "html", :content "<i>Returns</i>:&nbsp;"}
  {:type "text",
   :content
   "the array of strings computed by splitting this string\naround matches of the given regular expression\n\n"}
  {:type "html",
   :content
   "<i>Throws</i>:&nbsp;<pre>PatternSyntaxException</pre>:&nbsp;"}
  {:type "text",
   :content "if the regular expression's syntax is invalid"}]}

{:doc-fragments
 [{:type "text", :content "Compares this string to the specified "}
  {:type "html", :content "<pre>CharSequence</pre> "}
  {:type "text", :content ".  The\nresult is "}
  {:type "html", :content "<pre>true</pre> "}
  {:type "text", :content " if and only if this "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text",
   :content
   " represents the\nsame sequence of char values as the specified sequence. Note that if the\n"}
  {:type "html", :content "<pre>CharSequence</pre> "}
  {:type "text", :content " is a "}
  {:type "html", :content "<pre>StringBuffer</pre> "}
  {:type "text",
   :content
   " then the method\nsynchronizes on it.\n\nFor finer-grained String comparison, refer to\n"}
  {:type "html", :content "<pre>java.text.Collator</pre> "}
  {:type "text", :content "."}],
 :doc-first-sentence-fragments
 [{:type "text", :content "Compares this string to the specified "}
  {:type "html", :content "<pre>CharSequence</pre> "}
  {:type "text", :content "."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>cs</pre>:&nbsp;"}
  {:type "text", :content "The sequence to compare this "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text", :content " against\n\n"}
  {:type "html", :content "<i>Returns</i>:&nbsp; <pre>true</pre> "}
  {:type "text", :content " if this "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text",
   :content
   " represents the same\nsequence of char values as the specified sequence, "}
  {:type "html", :content "<pre>\n          false</pre> "}
  {:type "text", :content " otherwise"}]}

{:doc-fragments
 [{:type "text", :content "Compares this string to the specified "}
  {:type "html", :content "<pre>StringBuffer</pre> "}
  {:type "text", :content ".  The result\nis "}
  {:type "html", :content "<pre>true</pre> "}
  {:type "text", :content " if and only if this "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text",
   :content
   " represents the same\nsequence of characters as the specified "}
  {:type "html", :content "<pre>StringBuffer</pre> "}
  {:type "text", :content ". This method\nsynchronizes on the "}
  {:type "html", :content "<pre>StringBuffer</pre> "}
  {:type "text",
   :content ".\n\nFor finer-grained String comparison, refer to\n"}
  {:type "html", :content "<pre>java.text.Collator</pre> "}
  {:type "text", :content "."}],
 :doc-first-sentence-fragments
 [{:type "text", :content "Compares this string to the specified "}
  {:type "html", :content "<pre>StringBuffer</pre> "}
  {:type "text", :content "."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>sb</pre>:&nbsp;"}
  {:type "text", :content "The "}
  {:type "html", :content "<pre>StringBuffer</pre> "}
  {:type "text", :content " to compare this "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text", :content " against\n\n"}
  {:type "html", :content "<i>Returns</i>:&nbsp; <pre>true</pre> "}
  {:type "text", :content " if this "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text",
   :content
   " represents the same\nsequence of characters as the specified "}
  {:type "html", :content "<pre>StringBuffer</pre> "}
  {:type "text", :content ",\n"}
  {:type "html", :content "<pre>false</pre> "}
  {:type "text", :content " otherwise"}]}

{:doc-fragments
 [{:type "text",
   :content
   "Returns a hash code for this string. The hash code for a\n"}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text", :content " object is computed as\n"}
  {:type "html",
   :content
   "<blockquote> <pre> \n s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]\n  </pre> </blockquote>"}
  {:type "text", :content "\nusing "}
  {:type "html", :content "<pre>int</pre> "}
  {:type "text", :content " arithmetic, where "}
  {:type "html", :content "<pre>s[i]</pre> "}
  {:type "text", :content " is the\n"}
  {:type "html", :content "<i> i </i>"}
  {:type "text", :content "th character of the string, "}
  {:type "html", :content "<pre>n</pre> "}
  {:type "text", :content " is the length of\nthe string, and "}
  {:type "html", :content "<pre>^</pre> "}
  {:type "text",
   :content
   " indicates exponentiation.\n(The hash value of the empty string is zero.)"}],
 :doc-first-sentence-fragments
 [{:type "text", :content "Returns a hash code for this string."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html", :content "<i>Returns</i>:&nbsp;"}
  {:type "text", :content "a hash code value for this object."}]}

{:doc-fragments
 [{:type "text",
   :content
   "Replaces each substring of this string that matches the given "}
  {:type "html", :content "<pre> regular expression </pre>"}
  {:type "text",
   :content
   " with the\ngiven replacement.\n\nAn invocation of this method of the form\n"}
  {:type "html",
   :content
   "<i> str </i> <pre>.replaceAll(</pre>  <i> regex </i> <pre>,</pre> "}
  {:type "text", :content " "}
  {:type "html", :content "<i> repl </i> <pre>)</pre> "}
  {:type "text",
   :content "\nyields exactly the same result as the expression\n\n"}
  {:type "html",
   :content
   "<blockquote> \n  <code> \n  <pre>java.util.regex.Pattern</pre>  . <pre>java.util.regex.Pattern#compile(String)</pre>  ( <i> regex </i> ). <pre>java.util.regex.Pattern#matcher(java.lang.CharSequence)</pre>  ( <i> str </i> ). <pre>java.util.regex.Matcher#replaceAll(String)</pre>  ( <i> repl </i> )\n  </code> \n  </blockquote>"}
  {:type "text", :content "\n\nNote that backslashes ("}
  {:type "html", :content "<pre>\\</pre> "}
  {:type "text", :content ") and dollar signs ("}
  {:type "html", :content "<pre>$</pre> "}
  {:type "text",
   :content
   ") in the\nreplacement string may cause the results to be different than if it were\nbeing treated as a literal replacement string; see\n"}
  {:type "html",
   :content "<pre>java.util.regex.Matcher#replaceAll</pre> "}
  {:type "text", :content ".\nUse "}
  {:type "html",
   :content "<pre>java.util.regex.Matcher#quoteReplacement</pre> "}
  {:type "text",
   :content
   " to suppress the special\nmeaning of these characters, if desired."}],
 :doc-first-sentence-fragments
 [{:type "text",
   :content
   "Replaces each substring of this string that matches the given "}
  {:type "html", :content "<pre> regular expression </pre>"}
  {:type "text", :content " with the\ngiven replacement."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>regex</pre>:&nbsp;"}
  {:type "text",
   :content
   "the regular expression to which this string is to be matched\n\n"}
  {:type "html",
   :content "<i>Param</i>&nbsp;<pre>replacement</pre>:&nbsp;"}
  {:type "text",
   :content "the string to be substituted for each match\n\n"}
  {:type "html", :content "<i>Returns</i>:&nbsp;"}
  {:type "text", :content "The resulting "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text", :content "\n"}
  {:type "html",
   :content
   "<i>Throws</i>:&nbsp;<pre>PatternSyntaxException</pre>:&nbsp;"}
  {:type "text",
   :content "if the regular expression's syntax is invalid"}]}

{:doc-fragments
 [{:type "text",
   :content
   "Returns a canonical representation for the string object.\n\nA pool of strings, initially empty, is maintained privately by the\nclass "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text",
   :content
   ".\n\nWhen the intern method is invoked, if the pool already contains a\nstring equal to this "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text", :content " object as determined by\nthe "}
  {:type "html", :content "<pre>#equals(Object)</pre> "}
  {:type "text",
   :content
   " method, then the string from the pool is\nreturned. Otherwise, this "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text",
   :content " object is added to the\npool and a reference to this "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text",
   :content
   " object is returned.\n\nIt follows that for any two strings "}
  {:type "html", :content "<pre>s</pre> "}
  {:type "text", :content " and "}
  {:type "html", :content "<pre>t</pre> "}
  {:type "text", :content ",\n"}
  {:type "html", :content "<pre>s.intern() == t.intern()</pre> "}
  {:type "text", :content " is "}
  {:type "html", :content "<pre>true</pre> "}
  {:type "text", :content "\nif and only if "}
  {:type "html", :content "<pre>s.equals(t)</pre> "}
  {:type "text", :content " is "}
  {:type "html", :content "<pre>true</pre> "}
  {:type "text",
   :content
   ".\n\nAll literal strings and string-valued constant expressions are\ninterned. String literals are defined in section "}
  {:type "html", :content "{@jls 3.10.5}"}
  {:type "text", :content " of the\n"}
  {:type "html",
   :content "<cite> The Java Language Specification </cite>"}
  {:type "text", :content "."}],
 :doc-first-sentence-fragments
 [{:type "text",
   :content
   "Returns a canonical representation for the string object."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html", :content "<i>Returns</i>:&nbsp;"}
  {:type "text",
   :content
   "a string that has the same contents as this string, but is\nguaranteed to be from a pool of unique strings."}]}

{:doc-fragments
 [{:type "text", :content "Returns an "}
  {:type "html", :content "<pre>Optional</pre> "}
  {:type "text",
   :content
   " containing the nominal descriptor for this\ninstance, which is the instance itself."}],
 :doc-first-sentence-fragments
 [{:type "text", :content "Returns an "}
  {:type "html", :content "<pre>Optional</pre> "}
  {:type "text",
   :content
   " containing the nominal descriptor for this\ninstance, which is the instance itself."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html", :content "<i>Returns</i>:&nbsp;"}
  {:type "text", :content "an "}
  {:type "html", :content "<pre>Optional</pre> "}
  {:type "text", :content " describing the "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text", :content " instance"}]}

{:doc-fragments
 [{:type "text", :content "Returns the string representation of the "}
  {:type "html", :content "<pre>boolean</pre> "}
  {:type "text", :content " argument."}],
 :doc-first-sentence-fragments
 [{:type "text", :content "Returns the string representation of the "}
  {:type "html", :content "<pre>boolean</pre> "}
  {:type "text", :content " argument."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>b</pre>:&nbsp;"}
  {:type "text", :content "a "}
  {:type "html", :content "<pre>boolean</pre> "}
  {:type "text", :content ".\n\n"}
  {:type "html", :content "<i>Returns</i>:&nbsp;"}
  {:type "text", :content "if the argument is "}
  {:type "html", :content "<pre>true</pre> "}
  {:type "text", :content ", a string equal to\n"}
  {:type "html", :content "<pre>\"true\"</pre> "}
  {:type "text",
   :content " is returned; otherwise, a string equal to\n"}
  {:type "html", :content "<pre>\"false\"</pre> "}
  {:type "text", :content " is returned."}]}

{:doc-fragments
 [{:type "text", :content "Returns the string representation of the "}
  {:type "html", :content "<pre>double</pre> "}
  {:type "text",
   :content
   " argument.\n\nThe representation is exactly the one returned by the\n"}
  {:type "html", :content "<pre>Double.toString</pre> "}
  {:type "text", :content " method of one argument."}],
 :doc-first-sentence-fragments
 [{:type "text", :content "Returns the string representation of the "}
  {:type "html", :content "<pre>double</pre> "}
  {:type "text", :content " argument."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>d</pre>:&nbsp;"}
  {:type "text", :content "a "}
  {:type "html", :content "<pre>double</pre> "}
  {:type "text", :content ".\n\n"}
  {:type "html", :content "<i>Returns</i>:&nbsp;"}
  {:type "text", :content "a  string representation of the "}
  {:type "html", :content "<pre>double</pre> "}
  {:type "text", :content " argument."}]}

{:doc-fragments
 [{:type "text", :content "Returns the string representation of the "}
  {:type "html", :content "<pre>float</pre> "}
  {:type "text",
   :content
   " argument.\n\nThe representation is exactly the one returned by the\n"}
  {:type "html", :content "<pre>Float.toString</pre> "}
  {:type "text", :content " method of one argument."}],
 :doc-first-sentence-fragments
 [{:type "text", :content "Returns the string representation of the "}
  {:type "html", :content "<pre>float</pre> "}
  {:type "text", :content " argument."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>f</pre>:&nbsp;"}
  {:type "text", :content "a "}
  {:type "html", :content "<pre>float</pre> "}
  {:type "text", :content ".\n\n"}
  {:type "html", :content "<i>Returns</i>:&nbsp;"}
  {:type "text", :content "a string representation of the "}
  {:type "html", :content "<pre>float</pre> "}
  {:type "text", :content " argument."}]}

{:doc-fragments
 [{:type "text", :content "Returns the string representation of the "}
  {:type "html", :content "<pre>long</pre> "}
  {:type "text",
   :content
   " argument.\n\nThe representation is exactly the one returned by the\n"}
  {:type "html", :content "<pre>Long.toString</pre> "}
  {:type "text", :content " method of one argument."}],
 :doc-first-sentence-fragments
 [{:type "text", :content "Returns the string representation of the "}
  {:type "html", :content "<pre>long</pre> "}
  {:type "text", :content " argument."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>l</pre>:&nbsp;"}
  {:type "text", :content "a "}
  {:type "html", :content "<pre>long</pre> "}
  {:type "text", :content ".\n\n"}
  {:type "html", :content "<i>Returns</i>:&nbsp;"}
  {:type "text", :content "a string representation of the "}
  {:type "html", :content "<pre>long</pre> "}
  {:type "text", :content " argument."}]}

{:doc-fragments
 [{:type "text", :content "Returns the string representation of the "}
  {:type "html", :content "<pre>Object</pre> "}
  {:type "text", :content " argument."}],
 :doc-first-sentence-fragments
 [{:type "text", :content "Returns the string representation of the "}
  {:type "html", :content "<pre>Object</pre> "}
  {:type "text", :content " argument."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>obj</pre>:&nbsp;"}
  {:type "text", :content "an "}
  {:type "html", :content "<pre>Object</pre> "}
  {:type "text", :content ".\n\n"}
  {:type "html", :content "<i>Returns</i>:&nbsp;"}
  {:type "text", :content "if the argument is "}
  {:type "html", :content "<pre>null</pre> "}
  {:type "text", :content ", then a string equal to\n"}
  {:type "html", :content "<pre>\"null\"</pre> "}
  {:type "text", :content "; otherwise, the value of\n"}
  {:type "html", :content "<pre>obj.toString()</pre> "}
  {:type "text", :content " is returned."}]}

{:doc-fragments
 [{:type "text", :content "Returns the string representation of the "}
  {:type "html", :content "<pre>int</pre> "}
  {:type "text",
   :content
   " argument.\n\nThe representation is exactly the one returned by the\n"}
  {:type "html", :content "<pre>Integer.toString</pre> "}
  {:type "text", :content " method of one argument."}],
 :doc-first-sentence-fragments
 [{:type "text", :content "Returns the string representation of the "}
  {:type "html", :content "<pre>int</pre> "}
  {:type "text", :content " argument."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>i</pre>:&nbsp;"}
  {:type "text", :content "an "}
  {:type "html", :content "<pre>int</pre> "}
  {:type "text", :content ".\n\n"}
  {:type "html", :content "<i>Returns</i>:&nbsp;"}
  {:type "text", :content "a string representation of the "}
  {:type "html", :content "<pre>int</pre> "}
  {:type "text", :content " argument."}]}

{:doc-fragments
 [{:type "text",
   :content
   "Returns the string representation of a specific subarray of the\n"}
  {:type "html", :content "<pre>char</pre> "}
  {:type "text", :content " array argument.\n\nThe "}
  {:type "html", :content "<pre>offset</pre> "}
  {:type "text",
   :content
   " argument is the index of the first\ncharacter of the subarray. The "}
  {:type "html", :content "<pre>count</pre> "}
  {:type "text",
   :content
   " argument\nspecifies the length of the subarray. The contents of the subarray\nare copied; subsequent modification of the character array does not\naffect the returned string."}],
 :doc-first-sentence-fragments
 [{:type "text",
   :content
   "Returns the string representation of a specific subarray of the\n"}
  {:type "html", :content "<pre>char</pre> "}
  {:type "text", :content " array argument."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>data</pre>:&nbsp;"}
  {:type "text", :content "the character array.\n\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>offset</pre>:&nbsp;"}
  {:type "text", :content "initial offset of the subarray.\n\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>count</pre>:&nbsp;"}
  {:type "text", :content "length of the subarray.\n\n"}
  {:type "html", :content "<i>Returns</i>:&nbsp;"}
  {:type "text", :content "a "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text",
   :content
   " that contains the characters of the\nspecified subarray of the character array.\n\n"}
  {:type "html",
   :content
   "<i>Throws</i>:&nbsp;<pre>IndexOutOfBoundsException</pre>:&nbsp;"}
  {:type "text", :content "if "}
  {:type "html", :content "<pre>offset</pre> "}
  {:type "text", :content " is\nnegative, or "}
  {:type "html", :content "<pre>count</pre> "}
  {:type "text", :content " is negative, or\n"}
  {:type "html", :content "<pre>offset+count</pre> "}
  {:type "text", :content " is larger than\n"}
  {:type "html", :content "<pre>data.length</pre> "}
  {:type "text", :content "."}]}

{:doc-fragments
 [{:type "text", :content "Returns the string representation of the "}
  {:type "html", :content "<pre>char</pre> "}
  {:type "text", :content "\nargument."}],
 :doc-first-sentence-fragments
 [{:type "text", :content "Returns the string representation of the "}
  {:type "html", :content "<pre>char</pre> "}
  {:type "text", :content "\nargument."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>c</pre>:&nbsp;"}
  {:type "text", :content "a "}
  {:type "html", :content "<pre>char</pre> "}
  {:type "text", :content ".\n\n"}
  {:type "html", :content "<i>Returns</i>:&nbsp;"}
  {:type "text", :content "a string of length "}
  {:type "html", :content "<pre>1</pre> "}
  {:type "text",
   :content " containing\nas its single character the argument "}
  {:type "html", :content "<pre>c</pre> "}
  {:type "text", :content "."}]}

{:doc-fragments
 [{:type "text", :content "Returns the string representation of the "}
  {:type "html", :content "<pre>char</pre> "}
  {:type "text",
   :content
   " array\nargument. The contents of the character array are copied; subsequent\nmodification of the character array does not affect the returned\nstring."}],
 :doc-first-sentence-fragments
 [{:type "text", :content "Returns the string representation of the "}
  {:type "html", :content "<pre>char</pre> "}
  {:type "text", :content " array\nargument."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>data</pre>:&nbsp;"}
  {:type "text", :content "the character array.\n\n"}
  {:type "html", :content "<i>Returns</i>:&nbsp;"}
  {:type "text", :content "a "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text",
   :content " that contains the characters of the\ncharacter array."}]}

{:doc-fragments
 [{:type "text",
   :content
   "Compares this string to the specified object.  The result is "}
  {:type "html", :content "<pre>\n true</pre> "}
  {:type "text", :content " if and only if the argument is not "}
  {:type "html", :content "<pre>null</pre> "}
  {:type "text", :content " and is a "}
  {:type "html", :content "<pre>\n String</pre> "}
  {:type "text",
   :content
   " object that represents the same sequence of characters as this\nobject.\n\nFor finer-grained String comparison, refer to\n"}
  {:type "html", :content "<pre>java.text.Collator</pre> "}
  {:type "text", :content "."}],
 :doc-first-sentence-fragments
 [{:type "text",
   :content "Compares this string to the specified object."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html",
   :content "<i>Param</i>&nbsp;<pre>anObject</pre>:&nbsp;"}
  {:type "text", :content "The object to compare this "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text", :content " against\n\n"}
  {:type "html", :content "<i>Returns</i>:&nbsp; <pre>true</pre> "}
  {:type "text", :content " if the given object represents a "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text", :content "\nequivalent to this string, "}
  {:type "html", :content "<pre>false</pre> "}
  {:type "text", :content " otherwise"}]}

{:doc-fragments
 [{:type "text", :content "Returns the string representation of the "}
  {:type "html", :content "<pre>codePoint</pre> "}
  {:type "text", :content "\nargument."}],
 :doc-first-sentence-fragments
 [{:type "text", :content "Returns the string representation of the "}
  {:type "html", :content "<pre>codePoint</pre> "}
  {:type "text", :content "\nargument."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html",
   :content "<i>Param</i>&nbsp;<pre>codePoint</pre>:&nbsp;"}
  {:type "text", :content "a "}
  {:type "html", :content "<pre>codePoint</pre> "}
  {:type "text", :content ".\n\n"}
  {:type "html", :content "<i>Returns</i>:&nbsp;"}
  {:type "text", :content "a string of length "}
  {:type "html", :content "<pre>1</pre> "}
  {:type "text", :content " or "}
  {:type "html", :content "<pre>2</pre> "}
  {:type "text",
   :content " containing\nas its single character the argument "}
  {:type "html", :content "<pre>codePoint</pre> "}
  {:type "text", :content ".\n\n"}
  {:type "html",
   :content
   "<i>Throws</i>:&nbsp;<pre>IllegalArgumentException</pre>:&nbsp;"}
  {:type "text", :content "if the specified\n"}
  {:type "html", :content "<pre>codePoint</pre> "}
  {:type "text", :content " is not a "}
  {:type "html", :content "<pre>Character#isValidCodePoint</pre> "}
  {:type "text", :content "."}]}

{:doc-fragments
 [{:type "text",
   :content
   "This object (which is already a string!) is itself returned."}],
 :doc-first-sentence-fragments
 [{:type "text",
   :content
   "This object (which is already a string!) is itself returned."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html", :content "<i>Returns</i>:&nbsp;"}
  {:type "text", :content "the string itself."}]}

{:doc-fragments
 [{:type "text",
   :content "Tells whether or not this string matches the given "}
  {:type "html", :content "<pre> regular expression </pre>"}
  {:type "text",
   :content ".\n\nAn invocation of this method of the form\n"}
  {:type "html",
   :content
   "<i> str </i> <pre>.matches(</pre>  <i> regex </i> <pre>)</pre> "}
  {:type "text",
   :content " yields exactly the\nsame result as the expression\n\n"}
  {:type "html",
   :content
   "<blockquote> \n  <pre>java.util.regex.Pattern</pre>  . <pre>java.util.regex.Pattern#matches(String,CharSequence)</pre>  \n  </blockquote>"}],
 :doc-first-sentence-fragments
 [{:type "text",
   :content "Tells whether or not this string matches the given "}
  {:type "html", :content "<pre> regular expression </pre>"}
  {:type "text", :content "."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>regex</pre>:&nbsp;"}
  {:type "text",
   :content
   "the regular expression to which this string is to be matched\n\n"}
  {:type "html", :content "<i>Returns</i>:&nbsp; <pre>true</pre> "}
  {:type "text",
   :content
   " if, and only if, this string matches the\ngiven regular expression\n\n"}
  {:type "html",
   :content
   "<i>Throws</i>:&nbsp;<pre>PatternSyntaxException</pre>:&nbsp;"}
  {:type "text",
   :content "if the regular expression's syntax is invalid"}]}

{:doc-fragments
 [{:type "text",
   :content
   "Returns a stream of lines extracted from this string,\nseparated by line terminators.\n\nA "}
  {:type "html", :content "<i> line terminator </i>"}
  {:type "text",
   :content " is one of the following:\na line feed character "}
  {:type "html", :content "<pre>\"\\n\"</pre> "}
  {:type "text", :content " (U+000A),\na carriage return character "}
  {:type "html", :content "<pre>\"\\r\"</pre> "}
  {:type "text",
   :content
   " (U+000D),\nor a carriage return followed immediately by a line feed\n"}
  {:type "html", :content "<pre>\"\\r\\n\"</pre> "}
  {:type "text", :content " (U+000D U+000A).\n\nA "}
  {:type "html", :content "<i> line </i>"}
  {:type "text",
   :content
   " is either a sequence of zero or more characters\nfollowed by a line terminator, or it is a sequence of one or\nmore characters followed by the end of the string. A\nline does not include the line terminator.\n\nThe stream returned by this method contains the lines from\nthis string in the order in which they occur."}],
 :doc-first-sentence-fragments
 [{:type "text",
   :content
   "Returns a stream of lines extracted from this string,\nseparated by line terminators."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html", :content "<i>Returns</i>:&nbsp;"}
  {:type "text",
   :content "the stream of lines extracted from this string"}]}

{:doc-fragments
 [{:type "text",
   :content
   "Returns the character (Unicode code point) at the specified\nindex. The index refers to "}
  {:type "html", :content "<pre>char</pre> "}
  {:type "text",
   :content " values\n(Unicode code units) and ranges from "}
  {:type "html", :content "<pre>0</pre> "}
  {:type "text", :content " to\n"}
  {:type "html", :content "<pre>#length()</pre>  <pre> - 1</pre> "}
  {:type "text", :content ".\n\nIf the "}
  {:type "html", :content "<pre>char</pre> "}
  {:type "text",
   :content
   " value specified at the given index\nis in the high-surrogate range, the following index is less\nthan the length of this "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text", :content ", and the\n"}
  {:type "html", :content "<pre>char</pre> "}
  {:type "text",
   :content
   " value at the following index is in the\nlow-surrogate range, then the supplementary code point\ncorresponding to this surrogate pair is returned. Otherwise,\nthe "}
  {:type "html", :content "<pre>char</pre> "}
  {:type "text", :content " value at the given index is returned."}],
 :doc-first-sentence-fragments
 [{:type "text",
   :content
   "Returns the character (Unicode code point) at the specified\nindex."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>index</pre>:&nbsp;"}
  {:type "text", :content "the index to the "}
  {:type "html", :content "<pre>char</pre> "}
  {:type "text", :content " values\n\n"}
  {:type "html", :content "<i>Returns</i>:&nbsp;"}
  {:type "text",
   :content "the code point value of the character at the\n"}
  {:type "html", :content "<pre>index</pre> "}
  {:type "text", :content "\n"}
  {:type "html",
   :content
   "<i>Throws</i>:&nbsp;<pre>IndexOutOfBoundsException</pre>:&nbsp;"}
  {:type "text", :content "if the "}
  {:type "html", :content "<pre>index</pre> "}
  {:type "text",
   :content
   "\nargument is negative or not less than the length of this\nstring."}]}

{:doc-fragments
 [{:type "text", :content "Returns "}
  {:type "html", :content "<pre>true</pre> "}
  {:type "text", :content " if, and only if, "}
  {:type "html", :content "<pre>#length()</pre> "}
  {:type "text", :content " is "}
  {:type "html", :content "<pre>0</pre> "}
  {:type "text", :content "."}],
 :doc-first-sentence-fragments
 [{:type "text", :content "Returns "}
  {:type "html", :content "<pre>true</pre> "}
  {:type "text", :content " if, and only if, "}
  {:type "html", :content "<pre>#length()</pre> "}
  {:type "text", :content " is "}
  {:type "html", :content "<pre>0</pre> "}
  {:type "text", :content "."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html", :content "<i>Returns</i>:&nbsp; <pre>true</pre> "}
  {:type "text", :content " if "}
  {:type "html", :content "<pre>#length()</pre> "}
  {:type "text", :content " is "}
  {:type "html", :content "<pre>0</pre> "}
  {:type "text", :content ", otherwise\n"}
  {:type "html", :content "<pre>false</pre> "}]}

{:doc-fragments
 [{:type "text", :content "Resolves this instance as a "}
  {:type "html", :content "<pre>ConstantDesc</pre> "}
  {:type "text",
   :content ", the result of which is\nthe instance itself."}],
 :doc-first-sentence-fragments
 [{:type "text", :content "Resolves this instance as a "}
  {:type "html", :content "<pre>ConstantDesc</pre> "}
  {:type "text",
   :content ", the result of which is\nthe instance itself."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>lookup</pre>:&nbsp;"}
  {:type "text", :content "ignored\n\n"}
  {:type "html", :content "<i>Returns</i>:&nbsp;"}
  {:type "text", :content "the "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text", :content " instance"}]}

{:doc-fragments
 [{:type "text",
   :content
   "Cache if the hash has been calculated as actually being zero, enabling\nus to avoid recalculating this."}],
 :doc-first-sentence-fragments
 [{:type "text",
   :content
   "Cache if the hash has been calculated as actually being zero, enabling\nus to avoid recalculating this."}],
 :doc-block-tags-fragments []}

{:doc-fragments
 [{:type "text", :content "Constructs a new "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text",
   :content
   " by decoding the specified subarray of\nbytes using the platform's default charset.  The length of the new\n"}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text",
   :content
   " is a function of the charset, and hence may not be equal\nto the length of the subarray.\n\nThe behavior of this constructor when the given bytes are not valid\nin the default charset is unspecified.  The "}
  {:type "html",
   :content "<pre>java.nio.charset.CharsetDecoder</pre> "}
  {:type "text",
   :content
   " class should be used when more control\nover the decoding process is required."}],
 :doc-first-sentence-fragments
 [{:type "text", :content "Constructs a new "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text",
   :content
   " by decoding the specified subarray of\nbytes using the platform's default charset."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>bytes</pre>:&nbsp;"}
  {:type "text",
   :content "The bytes to be decoded into characters\n\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>offset</pre>:&nbsp;"}
  {:type "text", :content "The index of the first byte to decode\n\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>length</pre>:&nbsp;"}
  {:type "text", :content "The number of bytes to decode\n\n"}
  {:type "html",
   :content
   "<i>Throws</i>:&nbsp;<pre>IndexOutOfBoundsException</pre>:&nbsp;"}
  {:type "text", :content "If "}
  {:type "html", :content "<pre>offset</pre> "}
  {:type "text", :content " is negative, "}
  {:type "html", :content "<pre>length</pre> "}
  {:type "text", :content " is negative, or\n"}
  {:type "html", :content "<pre>offset</pre> "}
  {:type "text", :content " is greater than "}
  {:type "html", :content "<pre>bytes.length - length</pre> "}]}

{:doc-fragments
 [{:type "text", :content "Constructs a new "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text",
   :content
   " by decoding the specified array of\nbytes using the specified "}
  {:type "html", :content "<pre>java.nio.charset.Charset</pre> "}
  {:type "text", :content ".\nThe length of the new "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text",
   :content
   " is a function of the charset, and\nhence may not be equal to the length of the byte array.\n\nThis method always replaces malformed-input and unmappable-character\nsequences with this charset's default replacement string.  The "}
  {:type "html",
   :content "<pre>java.nio.charset.CharsetDecoder</pre> "}
  {:type "text",
   :content
   " class should be used when more control\nover the decoding process is required."}],
 :doc-first-sentence-fragments
 [{:type "text", :content "Constructs a new "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text",
   :content
   " by decoding the specified array of\nbytes using the specified "}
  {:type "html", :content "<pre>java.nio.charset.Charset</pre> "}
  {:type "text", :content "."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>bytes</pre>:&nbsp;"}
  {:type "text",
   :content "The bytes to be decoded into characters\n\n"}
  {:type "html",
   :content "<i>Param</i>&nbsp;<pre>charset</pre>:&nbsp;"}
  {:type "text", :content "The "}
  {:type "html", :content "<pre>java.nio.charset.Charset</pre> "}
  {:type "text", :content " to be used to\ndecode the "}
  {:type "html", :content "<pre>bytes</pre> "}]}

{:doc-fragments
 [{:type "text",
   :content
   "Allocates a new string that contains the sequence of characters\ncurrently contained in the string builder argument. The contents of the\nstring builder are copied; subsequent modification of the string builder\ndoes not affect the newly created string.\n\nThis constructor is provided to ease migration to "}
  {:type "html", :content "<pre>\n StringBuilder</pre> "}
  {:type "text",
   :content ". Obtaining a string from a string builder via the "}
  {:type "html", :content "<pre>\n toString</pre> "}
  {:type "text",
   :content
   " method is likely to run faster and is generally preferred."}],
 :doc-first-sentence-fragments
 [{:type "text",
   :content
   "Allocates a new string that contains the sequence of characters\ncurrently contained in the string builder argument."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html",
   :content "<i>Param</i>&nbsp;<pre>builder</pre>:&nbsp;"}
  {:type "text", :content "A "}
  {:type "html", :content "<pre>StringBuilder</pre> "}]}

{:doc-fragments
 [{:type "text", :content "Allocates a new "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text",
   :content
   " that contains characters from a subarray\nof the character array argument. The "}
  {:type "html", :content "<pre>offset</pre> "}
  {:type "text",
   :content
   " argument is the\nindex of the first character of the subarray and the "}
  {:type "html", :content "<pre>count</pre> "}
  {:type "text",
   :content
   "\nargument specifies the length of the subarray. The contents of the\nsubarray are copied; subsequent modification of the character array does\nnot affect the newly created string."}],
 :doc-first-sentence-fragments
 [{:type "text", :content "Allocates a new "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text",
   :content
   " that contains characters from a subarray\nof the character array argument."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>value</pre>:&nbsp;"}
  {:type "text", :content "Array that is the source of characters\n\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>offset</pre>:&nbsp;"}
  {:type "text", :content "The initial offset\n\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>count</pre>:&nbsp;"}
  {:type "text", :content "The length\n\n"}
  {:type "html",
   :content
   "<i>Throws</i>:&nbsp;<pre>IndexOutOfBoundsException</pre>:&nbsp;"}
  {:type "text", :content "If "}
  {:type "html", :content "<pre>offset</pre> "}
  {:type "text", :content " is negative, "}
  {:type "html", :content "<pre>count</pre> "}
  {:type "text", :content " is negative, or\n"}
  {:type "html", :content "<pre>offset</pre> "}
  {:type "text", :content " is greater than "}
  {:type "html", :content "<pre>value.length - count</pre> "}]}

{:doc-fragments
 [{:type "text",
   :content
   "Allocates a new string that contains the sequence of characters\ncurrently contained in the string buffer argument. The contents of the\nstring buffer are copied; subsequent modification of the string buffer\ndoes not affect the newly created string."}],
 :doc-first-sentence-fragments
 [{:type "text",
   :content
   "Allocates a new string that contains the sequence of characters\ncurrently contained in the string buffer argument."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>buffer</pre>:&nbsp;"}
  {:type "text", :content "A "}
  {:type "html", :content "<pre>StringBuffer</pre> "}]}

{:doc-fragments
 [{:type "text", :content "Allocates a new "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text",
   :content
   " containing characters constructed from\nan array of 8-bit integer values. Each character "}
  {:type "html", :content "<i> c </i>"}
  {:type "text",
   :content
   " in the\nresulting string is constructed from the corresponding component\n"}
  {:type "html", :content "<i> b </i>"}
  {:type "text", :content " in the byte array such that:\n\n"}
  {:type "html",
   :content
   "<blockquote> <pre> \n      <b> <i> c </i> </b>  == (char)(((hibyte  &amp;  0xff)  &lt; &lt;  8)\n                         | ( <b> <i> b </i> </b>   &amp;  0xff))\n  </pre> </blockquote>"}],
 :doc-first-sentence-fragments
 [{:type "text", :content "Allocates a new "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text",
   :content
   " containing characters constructed from\nan array of 8-bit integer values."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>ascii</pre>:&nbsp;"}
  {:type "text",
   :content "The bytes to be converted to characters\n\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>hibyte</pre>:&nbsp;"}
  {:type "text",
   :content "The top 8 bits of each 16-bit Unicode code unit"}]}

{:doc-fragments
 [{:type "text", :content "Allocates a new "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text",
   :content " that contains characters from a subarray\nof the "}
  {:type "html", :content "<pre> Unicode code point </pre>"}
  {:type "text", :content " array\nargument.  The "}
  {:type "html", :content "<pre>offset</pre> "}
  {:type "text",
   :content
   " argument is the index of the first code\npoint of the subarray and the "}
  {:type "html", :content "<pre>count</pre> "}
  {:type "text",
   :content
   " argument specifies the\nlength of the subarray.  The contents of the subarray are converted to\n"}
  {:type "html", :content "<pre>char</pre> "}
  {:type "text", :content "s; subsequent modification of the "}
  {:type "html", :content "<pre>int</pre> "}
  {:type "text",
   :content " array does not\naffect the newly created string."}],
 :doc-first-sentence-fragments
 [{:type "text", :content "Allocates a new "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text",
   :content " that contains characters from a subarray\nof the "}
  {:type "html", :content "<pre> Unicode code point </pre>"}
  {:type "text", :content " array\nargument."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html",
   :content "<i>Param</i>&nbsp;<pre>codePoints</pre>:&nbsp;"}
  {:type "text",
   :content "Array that is the source of Unicode code points\n\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>offset</pre>:&nbsp;"}
  {:type "text", :content "The initial offset\n\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>count</pre>:&nbsp;"}
  {:type "text", :content "The length\n\n"}
  {:type "html",
   :content
   "<i>Throws</i>:&nbsp;<pre>IllegalArgumentException</pre>:&nbsp;"}
  {:type "text",
   :content "If any invalid Unicode code point is found in "}
  {:type "html", :content "<pre>\n          codePoints</pre> "}
  {:type "text", :content "\n"}
  {:type "html",
   :content
   "<i>Throws</i>:&nbsp;<pre>IndexOutOfBoundsException</pre>:&nbsp;"}
  {:type "text", :content "If "}
  {:type "html", :content "<pre>offset</pre> "}
  {:type "text", :content " is negative, "}
  {:type "html", :content "<pre>count</pre> "}
  {:type "text", :content " is negative, or\n"}
  {:type "html", :content "<pre>offset</pre> "}
  {:type "text", :content " is greater than "}
  {:type "html", :content "<pre>codePoints.length - count</pre> "}]}

{:doc-fragments
 [{:type "text", :content "Initializes a newly created "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text",
   :content
   " object so that it represents\nan empty character sequence.  Note that use of this constructor is\nunnecessary since Strings are immutable."}],
 :doc-first-sentence-fragments
 [{:type "text", :content "Initializes a newly created "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text",
   :content
   " object so that it represents\nan empty character sequence."}],
 :doc-block-tags-fragments []}

{:doc-fragments
 [{:type "text", :content "Constructs a new "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text",
   :content
   " by decoding the specified array of bytes\nusing the specified "}
  {:type "html", :content "<pre>java.nio.charset.Charset</pre> "}
  {:type "text", :content ".  The\nlength of the new "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text",
   :content
   " is a function of the charset, and hence\nmay not be equal to the length of the byte array.\n\nThe behavior of this constructor when the given bytes are not valid\nin the given charset is unspecified.  The "}
  {:type "html",
   :content "<pre>java.nio.charset.CharsetDecoder</pre> "}
  {:type "text",
   :content
   " class should be used when more control\nover the decoding process is required."}],
 :doc-first-sentence-fragments
 [{:type "text", :content "Constructs a new "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text",
   :content
   " by decoding the specified array of bytes\nusing the specified "}
  {:type "html", :content "<pre>java.nio.charset.Charset</pre> "}
  {:type "text", :content "."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>bytes</pre>:&nbsp;"}
  {:type "text",
   :content "The bytes to be decoded into characters\n\n"}
  {:type "html",
   :content "<i>Param</i>&nbsp;<pre>charsetName</pre>:&nbsp;"}
  {:type "text", :content "The name of a supported "}
  {:type "html", :content "<pre>java.nio.charset.Charset</pre> "}
  {:type "text", :content "\n"}
  {:type "html",
   :content
   "<i>Throws</i>:&nbsp;<pre>UnsupportedEncodingException</pre>:&nbsp;"}
  {:type "text", :content "If the named charset is not supported"}]}

{:doc-fragments
 [{:type "text", :content "Constructs a new "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text",
   :content
   " by decoding the specified array of bytes\nusing the platform's default charset.  The length of the new "}
  {:type "html", :content "<pre>\n String</pre> "}
  {:type "text",
   :content
   " is a function of the charset, and hence may not be equal to the\nlength of the byte array.\n\nThe behavior of this constructor when the given bytes are not valid\nin the default charset is unspecified.  The "}
  {:type "html",
   :content "<pre>java.nio.charset.CharsetDecoder</pre> "}
  {:type "text",
   :content
   " class should be used when more control\nover the decoding process is required."}],
 :doc-first-sentence-fragments
 [{:type "text", :content "Constructs a new "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text",
   :content
   " by decoding the specified array of bytes\nusing the platform's default charset."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>bytes</pre>:&nbsp;"}
  {:type "text", :content "The bytes to be decoded into characters"}]}

{:doc-fragments
 [{:type "text", :content "Constructs a new "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text",
   :content
   " by decoding the specified subarray of\nbytes using the specified "}
  {:type "html", :content "<pre>java.nio.charset.Charset</pre> "}
  {:type "text", :content ".\nThe length of the new "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text",
   :content
   " is a function of the charset, and\nhence may not be equal to the length of the subarray.\n\nThis method always replaces malformed-input and unmappable-character\nsequences with this charset's default replacement string.  The "}
  {:type "html",
   :content "<pre>java.nio.charset.CharsetDecoder</pre> "}
  {:type "text",
   :content
   " class should be used when more control\nover the decoding process is required."}],
 :doc-first-sentence-fragments
 [{:type "text", :content "Constructs a new "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text",
   :content
   " by decoding the specified subarray of\nbytes using the specified "}
  {:type "html", :content "<pre>java.nio.charset.Charset</pre> "}
  {:type "text", :content "."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>bytes</pre>:&nbsp;"}
  {:type "text",
   :content "The bytes to be decoded into characters\n\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>offset</pre>:&nbsp;"}
  {:type "text", :content "The index of the first byte to decode\n\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>length</pre>:&nbsp;"}
  {:type "text", :content "The number of bytes to decode\n\n"}
  {:type "html",
   :content "<i>Param</i>&nbsp;<pre>charset</pre>:&nbsp;"}
  {:type "text", :content "The "}
  {:type "html", :content "<pre>java.nio.charset.Charset</pre> "}
  {:type "text", :content " to be used to\ndecode the "}
  {:type "html", :content "<pre>bytes</pre> "}
  {:type "text", :content "\n"}
  {:type "html",
   :content
   "<i>Throws</i>:&nbsp;<pre>IndexOutOfBoundsException</pre>:&nbsp;"}
  {:type "text", :content "If "}
  {:type "html", :content "<pre>offset</pre> "}
  {:type "text", :content " is negative, "}
  {:type "html", :content "<pre>length</pre> "}
  {:type "text", :content " is negative, or\n"}
  {:type "html", :content "<pre>offset</pre> "}
  {:type "text", :content " is greater than "}
  {:type "html", :content "<pre>bytes.length - length</pre> "}]}

{:doc-fragments
 [{:type "text", :content "Allocates a new "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text",
   :content
   " constructed from a subarray of an array\nof 8-bit integer values.\n\nThe "}
  {:type "html", :content "<pre>offset</pre> "}
  {:type "text",
   :content
   " argument is the index of the first byte of the\nsubarray, and the "}
  {:type "html", :content "<pre>count</pre> "}
  {:type "text",
   :content
   " argument specifies the length of the\nsubarray.\n\nEach "}
  {:type "html", :content "<pre>byte</pre> "}
  {:type "text", :content " in the subarray is converted to a "}
  {:type "html", :content "<pre>char</pre> "}
  {:type "text", :content " as\nspecified in the "}
  {:type "html", :content "<pre>#String(byte[],int)</pre> "}
  {:type "text", :content " constructor."}],
 :doc-first-sentence-fragments
 [{:type "text", :content "Allocates a new "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text",
   :content
   " constructed from a subarray of an array\nof 8-bit integer values."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>ascii</pre>:&nbsp;"}
  {:type "text",
   :content "The bytes to be converted to characters\n\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>hibyte</pre>:&nbsp;"}
  {:type "text",
   :content "The top 8 bits of each 16-bit Unicode code unit\n\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>offset</pre>:&nbsp;"}
  {:type "text", :content "The initial offset\n\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>count</pre>:&nbsp;"}
  {:type "text", :content "The length\n\n"}
  {:type "html",
   :content
   "<i>Throws</i>:&nbsp;<pre>IndexOutOfBoundsException</pre>:&nbsp;"}
  {:type "text", :content "If "}
  {:type "html", :content "<pre>offset</pre> "}
  {:type "text", :content " is negative, "}
  {:type "html", :content "<pre>count</pre> "}
  {:type "text", :content " is negative, or\n"}
  {:type "html", :content "<pre>offset</pre> "}
  {:type "text", :content " is greater than "}
  {:type "html", :content "<pre>ascii.length - count</pre> "}]}

{:doc-fragments
 [{:type "text", :content "Initializes a newly created "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text",
   :content
   " object so that it represents\nthe same sequence of characters as the argument; in other words, the\nnewly created string is a copy of the argument string. Unless an\nexplicit copy of "}
  {:type "html", :content "<pre>original</pre> "}
  {:type "text",
   :content
   " is needed, use of this constructor is\nunnecessary since Strings are immutable."}],
 :doc-first-sentence-fragments
 [{:type "text", :content "Initializes a newly created "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text",
   :content
   " object so that it represents\nthe same sequence of characters as the argument; in other words, the\nnewly created string is a copy of the argument string."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html",
   :content "<i>Param</i>&nbsp;<pre>original</pre>:&nbsp;"}
  {:type "text", :content "A "}
  {:type "html", :content "<pre>String</pre> "}]}

{:doc-fragments
 [{:type "text", :content "Constructs a new "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text",
   :content
   " by decoding the specified subarray of\nbytes using the specified charset.  The length of the new "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text",
   :content
   "\nis a function of the charset, and hence may not be equal to the length\nof the subarray.\n\nThe behavior of this constructor when the given bytes are not valid\nin the given charset is unspecified.  The "}
  {:type "html",
   :content "<pre>java.nio.charset.CharsetDecoder</pre> "}
  {:type "text",
   :content
   " class should be used when more control\nover the decoding process is required."}],
 :doc-first-sentence-fragments
 [{:type "text", :content "Constructs a new "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text",
   :content
   " by decoding the specified subarray of\nbytes using the specified charset."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>bytes</pre>:&nbsp;"}
  {:type "text",
   :content "The bytes to be decoded into characters\n\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>offset</pre>:&nbsp;"}
  {:type "text", :content "The index of the first byte to decode\n\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>length</pre>:&nbsp;"}
  {:type "text", :content "The number of bytes to decode\n\n"}
  {:type "html",
   :content "<i>Param</i>&nbsp;<pre>charsetName</pre>:&nbsp;"}
  {:type "text", :content "The name of a supported "}
  {:type "html", :content "<pre>java.nio.charset.Charset</pre> "}
  {:type "text", :content "\n"}
  {:type "html",
   :content
   "<i>Throws</i>:&nbsp;<pre>UnsupportedEncodingException</pre>:&nbsp;"}
  {:type "text", :content "If the named charset is not supported\n\n"}
  {:type "html",
   :content
   "<i>Throws</i>:&nbsp;<pre>IndexOutOfBoundsException</pre>:&nbsp;"}
  {:type "text", :content "If "}
  {:type "html", :content "<pre>offset</pre> "}
  {:type "text", :content " is negative, "}
  {:type "html", :content "<pre>length</pre> "}
  {:type "text", :content " is negative, or\n"}
  {:type "html", :content "<pre>offset</pre> "}
  {:type "text", :content " is greater than "}
  {:type "html", :content "<pre>bytes.length - length</pre> "}]}

{:doc-fragments
 [{:type "text", :content "Allocates a new "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text",
   :content
   " so that it represents the sequence of\ncharacters currently contained in the character array argument. The\ncontents of the character array are copied; subsequent modification of\nthe character array does not affect the newly created string."}],
 :doc-first-sentence-fragments
 [{:type "text", :content "Allocates a new "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text",
   :content
   " so that it represents the sequence of\ncharacters currently contained in the character array argument."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>value</pre>:&nbsp;"}
  {:type "text", :content "The initial value of the string"}]}

{:doc-fragments
 [{:type "text",
   :content
   "Formats using this string as the format string, and the supplied\narguments."}],
 :doc-first-sentence-fragments
 [{:type "text",
   :content
   "Formats using this string as the format string, and the supplied\narguments."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>args</pre>:&nbsp;"}
  {:type "text",
   :content
   "Arguments referenced by the format specifiers in this string.\n\n"}
  {:type "html", :content "<i>Returns</i>:&nbsp;"}
  {:type "text", :content "A formatted string"}]}

{:doc-fragments
 [{:type "text", :content "The value is used for character storage."}],
 :doc-first-sentence-fragments
 [{:type "text", :content "The value is used for character storage."}],
 :doc-block-tags-fragments []}

{:doc-fragments
 [{:type "text",
   :content
   "Returns a string whose value is this string, with all trailing\n"}
  {:type "html", :content "<pre>Character#isWhitespace(int)</pre> "}
  {:type "text", :content " removed.\n\nIf this "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text",
   :content
   " object represents an empty string,\nor if all characters in this string are\n"}
  {:type "html", :content "<pre>Character#isWhitespace(int)</pre> "}
  {:type "text",
   :content
   ", then an empty string\nis returned.\n\nOtherwise, returns a substring of this string beginning with the first\ncode point of this string up to and including the last code point\nthat is not a "}
  {:type "html", :content "<pre>Character#isWhitespace(int)</pre> "}
  {:type "text", :content ".\n\nThis method may be used to trim\n"}
  {:type "html", :content "<pre>Character#isWhitespace(int)</pre> "}
  {:type "text", :content " from\nthe end of a string."}],
 :doc-first-sentence-fragments
 [{:type "text",
   :content
   "Returns a string whose value is this string, with all trailing\n"}
  {:type "html", :content "<pre>Character#isWhitespace(int)</pre> "}
  {:type "text", :content " removed."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html", :content "<i>Returns</i>:&nbsp;"}
  {:type "text",
   :content
   "a string whose value is this string, with all trailing white\nspace removed"}]}

{:doc-fragments
 [{:type "text",
   :content
   "Concatenates the specified string to the end of this string.\n\nIf the length of the argument string is "}
  {:type "html", :content "<pre>0</pre> "}
  {:type "text", :content ", then this\n"}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text", :content " object is returned. Otherwise, a\n"}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text",
   :content
   " object is returned that represents a character\nsequence that is the concatenation of the character sequence\nrepresented by this "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text",
   :content
   " object and the character\nsequence represented by the argument string.\n\nExamples:\n"}
  {:type "html",
   :content
   "<blockquote> <pre> \n \"cares\".concat(\"s\") returns \"caress\"\n \"to\".concat(\"get\").concat(\"her\") returns \"together\"\n  </pre> </blockquote>"}],
 :doc-first-sentence-fragments
 [{:type "text",
   :content
   "Concatenates the specified string to the end of this string."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>str</pre>:&nbsp;"}
  {:type "text", :content "the "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text", :content " that is concatenated to the end\nof this "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text", :content ".\n\n"}
  {:type "html", :content "<i>Returns</i>:&nbsp;"}
  {:type "text",
   :content
   "a string that represents the concatenation of this object's\ncharacters followed by the string argument's characters."}]}

{:doc-fragments
 [{:type "text",
   :content
   "Returns the number of Unicode code points in the specified text\nrange of this "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text", :content ". The text range begins at the\nspecified "}
  {:type "html", :content "<pre>beginIndex</pre> "}
  {:type "text", :content " and extends to the\n"}
  {:type "html", :content "<pre>char</pre> "}
  {:type "text", :content " at index "}
  {:type "html", :content "<pre>endIndex - 1</pre> "}
  {:type "text", :content ". Thus the\nlength (in "}
  {:type "html", :content "<pre>char</pre> "}
  {:type "text", :content "s) of the text range is\n"}
  {:type "html", :content "<pre>endIndex-beginIndex</pre> "}
  {:type "text",
   :content
   ". Unpaired surrogates within\nthe text range count as one code point each."}],
 :doc-first-sentence-fragments
 [{:type "text",
   :content
   "Returns the number of Unicode code points in the specified text\nrange of this "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text", :content "."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html",
   :content "<i>Param</i>&nbsp;<pre>beginIndex</pre>:&nbsp;"}
  {:type "text", :content "the index to the first "}
  {:type "html", :content "<pre>char</pre> "}
  {:type "text", :content " of\nthe text range.\n\n"}
  {:type "html",
   :content "<i>Param</i>&nbsp;<pre>endIndex</pre>:&nbsp;"}
  {:type "text", :content "the index after the last "}
  {:type "html", :content "<pre>char</pre> "}
  {:type "text", :content " of\nthe text range.\n\n"}
  {:type "html", :content "<i>Returns</i>:&nbsp;"}
  {:type "text",
   :content
   "the number of Unicode code points in the specified text\nrange\n\n"}
  {:type "html",
   :content
   "<i>Throws</i>:&nbsp;<pre>IndexOutOfBoundsException</pre>:&nbsp;"}
  {:type "text", :content "if the\n"}
  {:type "html", :content "<pre>beginIndex</pre> "}
  {:type "text", :content " is negative, or "}
  {:type "html", :content "<pre>endIndex</pre> "}
  {:type "text", :content "\nis larger than the length of this "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text", :content ", or\n"}
  {:type "html", :content "<pre>beginIndex</pre> "}
  {:type "text", :content " is larger than "}
  {:type "html", :content "<pre>endIndex</pre> "}
  {:type "text", :content "."}]}

{:doc-fragments
 [{:type "text",
   :content
   "Compares two strings lexicographically, ignoring case\ndifferences. This method returns an integer whose sign is that of\ncalling "}
  {:type "html", :content "<pre>compareTo</pre> "}
  {:type "text",
   :content
   " with case folded versions of the strings\nwhere case differences have been eliminated by calling\n"}
  {:type "html",
   :content
   "<pre>Character.toLowerCase(Character.toUpperCase(int))</pre> "}
  {:type "text",
   :content
   " on\neach Unicode code point.\n\nNote that this method does "}
  {:type "html", :content "<em> not </em>"}
  {:type "text",
   :content
   " take locale into account,\nand will result in an unsatisfactory ordering for certain locales.\nThe "}
  {:type "html", :content "<pre>java.text.Collator</pre> "}
  {:type "text",
   :content " class provides locale-sensitive comparison."}],
 :doc-first-sentence-fragments
 [{:type "text",
   :content
   "Compares two strings lexicographically, ignoring case\ndifferences."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>str</pre>:&nbsp;"}
  {:type "text", :content "the "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text", :content " to be compared.\n\n"}
  {:type "html", :content "<i>Returns</i>:&nbsp;"}
  {:type "text",
   :content
   "a negative integer, zero, or a positive integer as the\nspecified String is greater than, equal to, or less\nthan this String, ignoring case considerations."}]}

{:doc-fragments
 [{:type "text", :content "Returns the index within this "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text", :content " that is\noffset from the given "}
  {:type "html", :content "<pre>index</pre> "}
  {:type "text", :content " by\n"}
  {:type "html", :content "<pre>codePointOffset</pre> "}
  {:type "text",
   :content
   " code points. Unpaired surrogates\nwithin the text range given by "}
  {:type "html", :content "<pre>index</pre> "}
  {:type "text", :content " and\n"}
  {:type "html", :content "<pre>codePointOffset</pre> "}
  {:type "text", :content " count as one code point each."}],
 :doc-first-sentence-fragments
 [{:type "text", :content "Returns the index within this "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text", :content " that is\noffset from the given "}
  {:type "html", :content "<pre>index</pre> "}
  {:type "text", :content " by\n"}
  {:type "html", :content "<pre>codePointOffset</pre> "}
  {:type "text", :content " code points."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>index</pre>:&nbsp;"}
  {:type "text", :content "the index to be offset\n\n"}
  {:type "html",
   :content "<i>Param</i>&nbsp;<pre>codePointOffset</pre>:&nbsp;"}
  {:type "text", :content "the offset in code points\n\n"}
  {:type "html", :content "<i>Returns</i>:&nbsp;"}
  {:type "text", :content "the index within this "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text", :content "\n"}
  {:type "html",
   :content
   "<i>Throws</i>:&nbsp;<pre>IndexOutOfBoundsException</pre>:&nbsp;"}
  {:type "text", :content "if "}
  {:type "html", :content "<pre>index</pre> "}
  {:type "text",
   :content "\nis negative or larger then the length of this\n"}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text", :content ", or if "}
  {:type "html", :content "<pre>codePointOffset</pre> "}
  {:type "text",
   :content " is positive\nand the substring starting with "}
  {:type "html", :content "<pre>index</pre> "}
  {:type "text", :content " has fewer\nthan "}
  {:type "html", :content "<pre>codePointOffset</pre> "}
  {:type "text", :content " code points,\nor if "}
  {:type "html", :content "<pre>codePointOffset</pre> "}
  {:type "text", :content " is negative and the substring\nbefore "}
  {:type "html", :content "<pre>index</pre> "}
  {:type "text", :content " has fewer than the absolute value\nof "}
  {:type "html", :content "<pre>codePointOffset</pre> "}
  {:type "text", :content " code points."}]}

{:doc-fragments
 [{:type "text", :content "Compares this "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text", :content " to another "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text",
   :content
   ", ignoring case\nconsiderations.  Two strings are considered equal ignoring case if they\nare of the same length and corresponding Unicode code points in the two\nstrings are equal ignoring case.\n\nTwo Unicode code points are considered the same\nignoring case if at least one of the following is true:\n"}
  {:type "html",
   :content
   "<ul> \n    <li>  The two Unicode code points are the same (as compared by the\n         <pre>==</pre>   operator)\n    <li>  Calling  <pre>Character.toLowerCase(Character.toUpperCase(int))</pre>  \n        on each Unicode code point produces the same result\n  </ul>"}
  {:type "text", :content "\n\nNote that this method does "}
  {:type "html", :content "<em> not </em>"}
  {:type "text",
   :content
   " take locale into account, and\nwill result in unsatisfactory results for certain locales.  The\n"}
  {:type "html", :content "<pre>java.text.Collator</pre> "}
  {:type "text",
   :content " class provides locale-sensitive comparison."}],
 :doc-first-sentence-fragments
 [{:type "text", :content "Compares this "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text", :content " to another "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text", :content ", ignoring case\nconsiderations."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html",
   :content "<i>Param</i>&nbsp;<pre>anotherString</pre>:&nbsp;"}
  {:type "text", :content "The "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text", :content " to compare this "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text", :content " against\n\n"}
  {:type "html", :content "<i>Returns</i>:&nbsp; <pre>true</pre> "}
  {:type "text", :content " if the argument is not "}
  {:type "html", :content "<pre>null</pre> "}
  {:type "text", :content " and it\nrepresents an equivalent "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text", :content " ignoring case; "}
  {:type "html", :content "<pre>\n          false</pre> "}
  {:type "text", :content " otherwise"}]}

{:doc-fragments
 [{:type "text",
   :content "Converts this string to a new character array."}],
 :doc-first-sentence-fragments
 [{:type "text",
   :content "Converts this string to a new character array."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html", :content "<i>Returns</i>:&nbsp;"}
  {:type "text",
   :content
   "a newly allocated character array whose length is the length\nof this string and whose contents are initialized to contain\nthe character sequence represented by this string."}]}

{:doc-fragments
 [{:type "text",
   :content
   "Class String is special cased within the Serialization Stream Protocol.\n\nA String instance is written into an ObjectOutputStream according to\n"}
  {:type "html",
   :content
   "<pre> \n Object Serialization Specification, Section 6.2, \"Stream Elements\" </pre>"}],
 :doc-first-sentence-fragments
 [{:type "text",
   :content
   "Class String is special cased within the Serialization Stream Protocol."}],
 :doc-block-tags-fragments []}

{:doc-fragments
 [{:type "text",
   :content
   "Replaces each substring of this string that matches the literal target\nsequence with the specified literal replacement sequence. The\nreplacement proceeds from the beginning of the string to the end, for\nexample, replacing \"aa\" with \"b\" in the string \"aaa\" will result in\n\"ba\" rather than \"ab\"."}],
 :doc-first-sentence-fragments
 [{:type "text",
   :content
   "Replaces each substring of this string that matches the literal target\nsequence with the specified literal replacement sequence."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>target</pre>:&nbsp;"}
  {:type "text",
   :content "The sequence of char values to be replaced\n\n"}
  {:type "html",
   :content "<i>Param</i>&nbsp;<pre>replacement</pre>:&nbsp;"}
  {:type "text",
   :content "The replacement sequence of char values\n\n"}
  {:type "html", :content "<i>Returns</i>:&nbsp;"}
  {:type "text", :content "The resulting string"}]}

{:doc-fragments
 [{:type "text",
   :content
   "Returns a string resulting from replacing all occurrences of\n"}
  {:type "html", :content "<pre>oldChar</pre> "}
  {:type "text", :content " in this string with "}
  {:type "html", :content "<pre>newChar</pre> "}
  {:type "text", :content ".\n\nIf the character "}
  {:type "html", :content "<pre>oldChar</pre> "}
  {:type "text",
   :content
   " does not occur in the\ncharacter sequence represented by this "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text", :content " object,\nthen a reference to this "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text", :content " object is returned.\nOtherwise, a "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text",
   :content
   " object is returned that\nrepresents a character sequence identical to the character sequence\nrepresented by this "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text", :content " object, except that every\noccurrence of "}
  {:type "html", :content "<pre>oldChar</pre> "}
  {:type "text", :content " is replaced by an occurrence\nof "}
  {:type "html", :content "<pre>newChar</pre> "}
  {:type "text", :content ".\n\nExamples:\n"}
  {:type "html",
   :content
   "<blockquote> <pre> \n \"mesquite in your cellar\".replace('e', 'o')\n         returns \"mosquito in your collar\"\n \"the war of baronets\".replace('r', 'y')\n         returns \"the way of bayonets\"\n \"sparring with a purple porpoise\".replace('p', 't')\n         returns \"starring with a turtle tortoise\"\n \"JonL\".replace('q', 'x') returns \"JonL\" (no change)\n  </pre> </blockquote>"}],
 :doc-first-sentence-fragments
 [{:type "text",
   :content
   "Returns a string resulting from replacing all occurrences of\n"}
  {:type "html", :content "<pre>oldChar</pre> "}
  {:type "text", :content " in this string with "}
  {:type "html", :content "<pre>newChar</pre> "}
  {:type "text", :content "."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html",
   :content "<i>Param</i>&nbsp;<pre>oldChar</pre>:&nbsp;"}
  {:type "text", :content "the old character.\n\n"}
  {:type "html",
   :content "<i>Param</i>&nbsp;<pre>newChar</pre>:&nbsp;"}
  {:type "text", :content "the new character.\n\n"}
  {:type "html", :content "<i>Returns</i>:&nbsp;"}
  {:type "text",
   :content
   "a string derived from this string by replacing every\noccurrence of "}
  {:type "html", :content "<pre>oldChar</pre> "}
  {:type "text", :content " with "}
  {:type "html", :content "<pre>newChar</pre> "}
  {:type "text", :content "."}]}

{:doc-fragments
 [{:type "text",
   :content
   "Returns a string whose value is this string, with escape sequences\ntranslated as if in a string literal.\n\nEscape sequences are translated as follows;\n"}
  {:type "html",
   :content
   "<table class=\"striped\"> \n    <caption style=\"display:none\"> Translation </caption> \n    <thead> \n    <tr> \n      <th scope=\"col\"> Escape </th> \n      <th scope=\"col\"> Name </th> \n      <th scope=\"col\"> Translation </th> \n    </tr> \n    </thead> \n    <tbody> \n    <tr> \n      <th scope=\"row\"> <pre>\\b</pre>  </th> \n      <td> backspace </td> \n      <td> <pre>U+0008</pre>  </td> \n    </tr> \n    <tr> \n      <th scope=\"row\"> <pre>\\t</pre>  </th> \n      <td> horizontal tab </td> \n      <td> <pre>U+0009</pre>  </td> \n    </tr> \n    <tr> \n      <th scope=\"row\"> <pre>\\n</pre>  </th> \n      <td> line feed </td> \n      <td> <pre>U+000A</pre>  </td> \n    </tr> \n    <tr> \n      <th scope=\"row\"> <pre>\\f</pre>  </th> \n      <td> form feed </td> \n      <td> <pre>U+000C</pre>  </td> \n    </tr> \n    <tr> \n      <th scope=\"row\"> <pre>\\r</pre>  </th> \n      <td> carriage return </td> \n      <td> <pre>U+000D</pre>  </td> \n    </tr> \n    <tr> \n      <th scope=\"row\"> <pre>\\s</pre>  </th> \n      <td> space </td> \n      <td> <pre>U+0020</pre>  </td> \n    </tr> \n    <tr> \n      <th scope=\"row\"> <pre>\\\"</pre>  </th> \n      <td> double quote </td> \n      <td> <pre>U+0022</pre>  </td> \n    </tr> \n    <tr> \n      <th scope=\"row\"> <pre>\\'</pre>  </th> \n      <td> single quote </td> \n      <td> <pre>U+0027</pre>  </td> \n    </tr> \n    <tr> \n      <th scope=\"row\"> <pre>\\\\</pre>  </th> \n      <td> backslash </td> \n      <td> <pre>U+005C</pre>  </td> \n    </tr> \n    <tr> \n      <th scope=\"row\"> <pre>\\0 - \\377</pre>  </th> \n      <td> octal escape </td> \n      <td> code point equivalents </td> \n    </tr> \n    <tr> \n      <th scope=\"row\"> <pre>\\<line-terminator></pre>  </th> \n      <td> continuation </td> \n      <td> discard </td> \n    </tr> \n    </tbody> \n  </table>"}],
 :doc-first-sentence-fragments
 [{:type "text",
   :content
   "Returns a string whose value is this string, with escape sequences\ntranslated as if in a string literal."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html",
   :content
   "<i>Throws</i>:&nbsp;<pre>IllegalArgumentException</pre>:&nbsp;"}
  {:type "text", :content "when an escape sequence is malformed.\n\n"}
  {:type "html", :content "<i>Returns</i>:&nbsp;"}
  {:type "text", :content "String with escape sequences translated."}]}

{:doc-fragments
 [{:type "text",
   :content
   "Copies characters from this string into the destination character\narray.\n\nThe first character to be copied is at index "}
  {:type "html", :content "<pre>srcBegin</pre> "}
  {:type "text",
   :content ";\nthe last character to be copied is at index "}
  {:type "html", :content "<pre>srcEnd-1</pre> "}
  {:type "text",
   :content "\n(thus the total number of characters to be copied is\n"}
  {:type "html", :content "<pre>srcEnd-srcBegin</pre> "}
  {:type "text",
   :content "). The characters are copied into the\nsubarray of "}
  {:type "html", :content "<pre>dst</pre> "}
  {:type "text", :content " starting at index "}
  {:type "html", :content "<pre>dstBegin</pre> "}
  {:type "text", :content "\nand ending at index:\n"}
  {:type "html",
   :content
   "<blockquote> <pre> \n     dstBegin + (srcEnd-srcBegin) - 1\n  </pre> </blockquote>"}],
 :doc-first-sentence-fragments
 [{:type "text",
   :content
   "Copies characters from this string into the destination character\narray."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html",
   :content "<i>Param</i>&nbsp;<pre>srcBegin</pre>:&nbsp;"}
  {:type "text",
   :content "index of the first character in the string\nto copy.\n\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>srcEnd</pre>:&nbsp;"}
  {:type "text",
   :content
   "index after the last character in the string\nto copy.\n\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>dst</pre>:&nbsp;"}
  {:type "text", :content "the destination array.\n\n"}
  {:type "html",
   :content "<i>Param</i>&nbsp;<pre>dstBegin</pre>:&nbsp;"}
  {:type "text",
   :content "the start offset in the destination array.\n\n"}
  {:type "html",
   :content
   "<i>Throws</i>:&nbsp;<pre>IndexOutOfBoundsException</pre>:&nbsp;"}
  {:type "text", :content "If any of the following\nis true:\n"}
  {:type "html",
   :content
   "<ul> <li> <pre>srcBegin</pre>   is negative.\n             <li> <pre>srcBegin</pre>   is greater than  <pre>srcEnd</pre>  \n             <li> <pre>srcEnd</pre>   is greater than the length of this\n                string\n             <li> <pre>dstBegin</pre>   is negative\n             <li> <pre>dstBegin+(srcEnd-srcBegin)</pre>   is larger than\n                 <pre>dst.length</pre>  </ul>"}]}

{:doc-fragments
 [{:type "text",
   :content "If String compaction is disabled, the bytes in "}
  {:type "html", :content "<pre>value</pre> "}
  {:type "text",
   :content
   " are\nalways encoded in UTF16.\n\nFor methods with several possible implementation paths, when String\ncompaction is disabled, only one code path is taken.\n\nThe instance field value is generally opaque to optimizing JIT\ncompilers. Therefore, in performance-sensitive place, an explicit\ncheck of the static boolean "}
  {:type "html", :content "<pre>COMPACT_STRINGS</pre> "}
  {:type "text", :content " is done first\nbefore checking the "}
  {:type "html", :content "<pre>coder</pre> "}
  {:type "text", :content " field since the static boolean\n"}
  {:type "html", :content "<pre>COMPACT_STRINGS</pre> "}
  {:type "text",
   :content
   " would be constant folded away by an\noptimizing JIT compiler. The idioms for these cases are as follows.\n\nFor code such as:\n\nif (coder == LATIN1) { ... }\n\ncan be written more optimally as\n\nif (coder() == LATIN1) { ... }\n\nor:\n\nif (COMPACT_STRINGS "}
  {:type "html", :content "& &"}
  {:type "text",
   :content
   " coder == LATIN1) { ... }\n\nAn optimizing JIT compiler can fold the above conditional as:\n\nCOMPACT_STRINGS == true  => if (coder == LATIN1) { ... }\nCOMPACT_STRINGS == false => if (false)           { ... }"}],
 :doc-first-sentence-fragments
 [{:type "text",
   :content "If String compaction is disabled, the bytes in "}
  {:type "html", :content "<pre>value</pre> "}
  {:type "text", :content " are\nalways encoded in UTF16."}],
 :doc-block-tags-fragments []}

{:doc-fragments
 [{:type "text", :content "Cache the hash code for the string"}],
 :doc-first-sentence-fragments
 [{:type "text", :content "Cache the hash code for the string"}],
 :doc-block-tags-fragments []}

{:doc-fragments
 [{:type "text", :content "A Comparator that orders "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text", :content " objects as by\n"}
  {:type "html", :content "<pre>#compareToIgnoreCase(String)</pre> "}
  {:type "text",
   :content
   ".\nThis comparator is serializable.\n\nNote that this Comparator does "}
  {:type "html", :content "<em> not </em>"}
  {:type "text",
   :content
   " take locale into account,\nand will result in an unsatisfactory ordering for certain locales.\nThe "}
  {:type "html", :content "<pre>java.text.Collator</pre> "}
  {:type "text",
   :content " class provides locale-sensitive comparison."}],
 :doc-first-sentence-fragments
 [{:type "text", :content "A Comparator that orders "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text", :content " objects as by\n"}
  {:type "html", :content "<pre>#compareToIgnoreCase(String)</pre> "}
  {:type "text", :content "."}],
 :doc-block-tags-fragments []}

{:doc-fragments
 [{:type "text",
   :content
   "Returns a string that is a substring of this string. The\nsubstring begins at the specified "}
  {:type "html", :content "<pre>beginIndex</pre> "}
  {:type "text", :content " and\nextends to the character at index "}
  {:type "html", :content "<pre>endIndex - 1</pre> "}
  {:type "text", :content ".\nThus the length of the substring is "}
  {:type "html", :content "<pre>endIndex-beginIndex</pre> "}
  {:type "text", :content ".\n\nExamples:\n"}
  {:type "html",
   :content
   "<blockquote> <pre> \n \"hamburger\".substring(4, 8) returns \"urge\"\n \"smiles\".substring(1, 5) returns \"mile\"\n  </pre> </blockquote>"}],
 :doc-first-sentence-fragments
 [{:type "text",
   :content "Returns a string that is a substring of this string."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html",
   :content "<i>Param</i>&nbsp;<pre>beginIndex</pre>:&nbsp;"}
  {:type "text", :content "the beginning index, inclusive.\n\n"}
  {:type "html",
   :content "<i>Param</i>&nbsp;<pre>endIndex</pre>:&nbsp;"}
  {:type "text", :content "the ending index, exclusive.\n\n"}
  {:type "html", :content "<i>Returns</i>:&nbsp;"}
  {:type "text", :content "the specified substring.\n\n"}
  {:type "html",
   :content
   "<i>Throws</i>:&nbsp;<pre>IndexOutOfBoundsException</pre>:&nbsp;"}
  {:type "text", :content "if the\n"}
  {:type "html", :content "<pre>beginIndex</pre> "}
  {:type "text", :content " is negative, or\n"}
  {:type "html", :content "<pre>endIndex</pre> "}
  {:type "text", :content " is larger than the length of\nthis "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text", :content " object, or\n"}
  {:type "html", :content "<pre>beginIndex</pre> "}
  {:type "text", :content " is larger than\n"}
  {:type "html", :content "<pre>endIndex</pre> "}
  {:type "text", :content "."}]}

{:doc-fragments
 [{:type "text",
   :content
   "Returns a string that is a substring of this string. The\nsubstring begins with the character at the specified index and\nextends to the end of this string.\n\nExamples:\n"}
  {:type "html",
   :content
   "<blockquote> <pre> \n \"unhappy\".substring(2) returns \"happy\"\n \"Harbison\".substring(3) returns \"bison\"\n \"emptiness\".substring(9) returns \"\" (an empty string)\n  </pre> </blockquote>"}],
 :doc-first-sentence-fragments
 [{:type "text",
   :content "Returns a string that is a substring of this string."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html",
   :content "<i>Param</i>&nbsp;<pre>beginIndex</pre>:&nbsp;"}
  {:type "text", :content "the beginning index, inclusive.\n\n"}
  {:type "html", :content "<i>Returns</i>:&nbsp;"}
  {:type "text", :content "the specified substring.\n\n"}
  {:type "html",
   :content
   "<i>Throws</i>:&nbsp;<pre>IndexOutOfBoundsException</pre>:&nbsp;"}
  {:type "text", :content "if\n"}
  {:type "html", :content "<pre>beginIndex</pre> "}
  {:type "text",
   :content " is negative or larger than the\nlength of this "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text", :content " object."}]}

{:doc-fragments
 [{:type "text",
   :content
   "Returns true if and only if this string contains the specified\nsequence of char values."}],
 :doc-first-sentence-fragments
 [{:type "text",
   :content
   "Returns true if and only if this string contains the specified\nsequence of char values."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>s</pre>:&nbsp;"}
  {:type "text", :content "the sequence to search for\n\n"}
  {:type "html", :content "<i>Returns</i>:&nbsp;"}
  {:type "text", :content "true if this string contains "}
  {:type "html", :content "<pre>s</pre> "}
  {:type "text", :content ", false otherwise"}]}

{:doc-fragments
 [{:type "text",
   :content "This method allows the application of a function to "}
  {:type "html", :content "<pre>this</pre> "}
  {:type "text",
   :content
   "\nstring. The function should expect a single String argument\nand produce an "}
  {:type "html", :content "<pre>R</pre> "}
  {:type "text", :content " result.\n\nAny exception thrown by "}
  {:type "html", :content "<pre>f.apply()</pre> "}
  {:type "text", :content " will be propagated to the\ncaller."}],
 :doc-first-sentence-fragments
 [{:type "text",
   :content "This method allows the application of a function to "}
  {:type "html", :content "<pre>this</pre> "}
  {:type "text", :content "\nstring."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>f</pre>:&nbsp;"}
  {:type "text", :content "a function to apply\n\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>R</pre>:&nbsp;"}
  {:type "text", :content "the type of the result\n\n"}
  {:type "html", :content "<i>Returns</i>:&nbsp;"}
  {:type "text",
   :content "the result of applying the function to this string"}]}

{:doc-fragments
 [{:type "text",
   :content
   "Adjusts the indentation of each line of this string based on the value of\n"}
  {:type "html", :content "<pre>n</pre> "}
  {:type "text",
   :content
   ", and normalizes line termination characters.\n\nThis string is conceptually separated into lines using\n"}
  {:type "html", :content "<pre>String#lines()</pre> "}
  {:type "text",
   :content
   ". Each line is then adjusted as described below\nand then suffixed with a line feed "}
  {:type "html", :content "<pre>\"\\n\"</pre> "}
  {:type "text",
   :content
   " (U+000A). The resulting\nlines are then concatenated and returned.\n\nIf "}
  {:type "html", :content "<pre>n > 0</pre> "}
  {:type "text", :content " then "}
  {:type "html", :content "<pre>n</pre> "}
  {:type "text",
   :content
   " spaces (U+0020) are inserted at the\nbeginning of each line.\n\nIf "}
  {:type "html", :content "<pre>n < 0</pre> "}
  {:type "text", :content " then up to "}
  {:type "html", :content "<pre>n</pre> "}
  {:type "text", :content "\n"}
  {:type "html", :content "<pre>Character#isWhitespace(int)</pre> "}
  {:type "text",
   :content
   " are removed\nfrom the beginning of each line. If a given line does not contain\nsufficient white space then all leading\n"}
  {:type "html", :content "<pre>Character#isWhitespace(int)</pre> "}
  {:type "text",
   :content
   " are removed.\nEach white space character is treated as a single character. In\nparticular, the tab character "}
  {:type "html", :content "<pre>\"\\t\"</pre> "}
  {:type "text",
   :content
   " (U+0009) is considered a\nsingle character; it is not expanded.\n\nIf "}
  {:type "html", :content "<pre>n == 0</pre> "}
  {:type "text",
   :content
   " then the line remains unchanged. However, line\nterminators are still normalized."}],
 :doc-first-sentence-fragments
 [{:type "text",
   :content
   "Adjusts the indentation of each line of this string based on the value of\n"}
  {:type "html", :content "<pre>n</pre> "}
  {:type "text",
   :content ", and normalizes line termination characters."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>n</pre>:&nbsp;"}
  {:type "text", :content "number of leading\n"}
  {:type "html", :content "<pre>Character#isWhitespace(int)</pre> "}
  {:type "text", :content "\nto add or remove\n\n"}
  {:type "html", :content "<i>Returns</i>:&nbsp;"}
  {:type "text",
   :content
   "string with indentation adjusted and line endings normalized"}]}

{:doc-fragments
 [{:type "text", :content "Converts all of the characters in this "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text",
   :content
   " to upper\ncase using the rules of the default locale. This method is equivalent to\n"}
  {:type "html",
   :content "<pre>toUpperCase(Locale.getDefault())</pre> "}
  {:type "text", :content ".\n\n"}
  {:type "html", :content "<b> Note: </b>"}
  {:type "text",
   :content
   " This method is locale sensitive, and may produce unexpected\nresults if used for strings that are intended to be interpreted locale\nindependently.\nExamples are programming language identifiers, protocol keys, and HTML\ntags.\nFor instance, "}
  {:type "html", :content "<pre>\"title\".toUpperCase()</pre> "}
  {:type "text", :content " in a Turkish locale\nreturns "}
  {:type "html", :content "<pre>\"T\\u0130TLE\"</pre> "}
  {:type "text",
   :content
   ", where '\\u0130' is the\nLATIN CAPITAL LETTER I WITH DOT ABOVE character.\nTo obtain correct results for locale insensitive strings, use\n"}
  {:type "html", :content "<pre>toUpperCase(Locale.ROOT)</pre> "}
  {:type "text", :content "."}],
 :doc-first-sentence-fragments
 [{:type "text", :content "Converts all of the characters in this "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text",
   :content " to upper\ncase using the rules of the default locale."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html", :content "<i>Returns</i>:&nbsp;"}
  {:type "text", :content "the "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text", :content ", converted to uppercase."}]}

{:doc-fragments
 [{:type "text", :content "Converts all of the characters in this "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text",
   :content " to upper\ncase using the rules of the given "}
  {:type "html", :content "<pre>Locale</pre> "}
  {:type "text",
   :content
   ". Case mapping is based\non the Unicode Standard version specified by the "}
  {:type "html", :content "<pre>java.lang.Character</pre> "}
  {:type "text",
   :content
   "\nclass. Since case mappings are not always 1:1 char mappings, the resulting\n"}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text",
   :content " may be a different length than the original "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text",
   :content
   ".\n\nExamples of locale-sensitive and 1:M case mappings are in the following table.\n\n"}
  {:type "html",
   :content
   "<table class=\"plain\"> \n  <caption style=\"display:none\"> Examples of locale-sensitive and 1:M case mappings. Shows Language code of locale, lower case, upper case, and description. </caption> \n  <thead> \n  <tr> \n    <th scope=\"col\"> Language Code of Locale </th> \n    <th scope=\"col\"> Lower Case </th> \n    <th scope=\"col\"> Upper Case </th> \n    <th scope=\"col\"> Description </th> \n  </tr> \n  </thead> \n  <tbody> \n  <tr> \n    <td> tr (Turkish) </td> \n    <th scope=\"row\" style=\"font-weight:normal; text-align:left\"> &#92; u0069 </th> \n    <td> &#92; u0130 </td> \n    <td> small letter i - &gt;  capital letter I with dot above </td> \n  </tr> \n  <tr> \n    <td> tr (Turkish) </td> \n    <th scope=\"row\" style=\"font-weight:normal; text-align:left\"> &#92; u0131 </th> \n    <td> &#92; u0049 </td> \n    <td> small letter dotless i - &gt;  capital letter I </td> \n  </tr> \n  <tr> \n    <td> (all) </td> \n    <th scope=\"row\" style=\"font-weight:normal; text-align:left\"> &#92; u00df </th> \n    <td> &#92; u0053  &#92; u0053 </td> \n    <td> small letter sharp s - &gt;  two letters: SS </td> \n  </tr> \n  <tr> \n    <td> (all) </td> \n    <th scope=\"row\" style=\"font-weight:normal; text-align:left\"> Fahrvergn &uuml; gen </th> \n    <td> FAHRVERGN &Uuml; GEN </td> \n    <td> </td> \n  </tr> \n  </tbody> \n  </table>"}],
 :doc-first-sentence-fragments
 [{:type "text", :content "Converts all of the characters in this "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text",
   :content " to upper\ncase using the rules of the given "}
  {:type "html", :content "<pre>Locale</pre> "}
  {:type "text", :content "."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>locale</pre>:&nbsp;"}
  {:type "text",
   :content "use the case transformation rules for this locale\n\n"}
  {:type "html", :content "<i>Returns</i>:&nbsp;"}
  {:type "text", :content "the "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text", :content ", converted to uppercase."}]}

{:doc-fragments
 [{:type "text",
   :content
   "Returns a formatted string using the specified locale, format string,\nand arguments."}],
 :doc-first-sentence-fragments
 [{:type "text",
   :content
   "Returns a formatted string using the specified locale, format string,\nand arguments."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>l</pre>:&nbsp;"}
  {:type "text", :content "The "}
  {:type "html", :content "<pre>java.util.Locale</pre> "}
  {:type "text", :content " to apply during\nformatting.  If "}
  {:type "html", :content "<pre>l</pre> "}
  {:type "text", :content " is "}
  {:type "html", :content "<pre>null</pre> "}
  {:type "text", :content " then no localization\nis applied.\n\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>format</pre>:&nbsp;"}
  {:type "text", :content "A "}
  {:type "html", :content "<pre> format string </pre>"}
  {:type "text", :content "\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>args</pre>:&nbsp;"}
  {:type "text",
   :content
   "Arguments referenced by the format specifiers in the format\nstring.  If there are more arguments than format specifiers, the\nextra arguments are ignored.  The number of arguments is\nvariable and may be zero.  The maximum number of arguments is\nlimited by the maximum dimension of a Java array as defined by\n"}
  {:type "html",
   :content "<cite> The Java Virtual Machine Specification </cite>"}
  {:type "text", :content ".\nThe behaviour on a\n"}
  {:type "html", :content "<pre>null</pre> "}
  {:type "text", :content " argument depends on the\n"}
  {:type "html", :content "<pre> conversion </pre>"}
  {:type "text", :content ".\n\n"}
  {:type "html",
   :content
   "<i>Throws</i>:&nbsp;<pre>java.util.IllegalFormatException</pre>:&nbsp;"}
  {:type "text",
   :content
   "If a format string contains an illegal syntax, a format\nspecifier that is incompatible with the given arguments,\ninsufficient arguments given the format string, or other\nillegal conditions.  For specification of all possible\nformatting errors, see the "}
  {:type "html", :content "<pre> Details </pre>"}
  {:type "text",
   :content " section of the\nformatter class specification\n\n"}
  {:type "html", :content "<i>Returns</i>:&nbsp;"}
  {:type "text", :content "A formatted string"}]}

{:doc-fragments
 [{:type "text",
   :content
   "Returns a formatted string using the specified format string and\narguments.\n\nThe locale always used is the one returned by "}
  {:type "html",
   :content
   "<pre>java.util.Locale#getDefault(java.util.Locale.Category)</pre> "}
  {:type "text", :content " with\n"}
  {:type "html",
   :content "<pre>java.util.Locale.Category#FORMAT</pre> "}
  {:type "text", :content " category specified."}],
 :doc-first-sentence-fragments
 [{:type "text",
   :content
   "Returns a formatted string using the specified format string and\narguments."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>format</pre>:&nbsp;"}
  {:type "text", :content "A "}
  {:type "html", :content "<pre> format string </pre>"}
  {:type "text", :content "\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>args</pre>:&nbsp;"}
  {:type "text",
   :content
   "Arguments referenced by the format specifiers in the format\nstring.  If there are more arguments than format specifiers, the\nextra arguments are ignored.  The number of arguments is\nvariable and may be zero.  The maximum number of arguments is\nlimited by the maximum dimension of a Java array as defined by\n"}
  {:type "html",
   :content "<cite> The Java Virtual Machine Specification </cite>"}
  {:type "text", :content ".\nThe behaviour on a\n"}
  {:type "html", :content "<pre>null</pre> "}
  {:type "text", :content " argument depends on the "}
  {:type "html", :content "<pre> conversion </pre>"}
  {:type "text", :content ".\n\n"}
  {:type "html",
   :content
   "<i>Throws</i>:&nbsp;<pre>java.util.IllegalFormatException</pre>:&nbsp;"}
  {:type "text",
   :content
   "If a format string contains an illegal syntax, a format\nspecifier that is incompatible with the given arguments,\ninsufficient arguments given the format string, or other\nillegal conditions.  For specification of all possible\nformatting errors, see the "}
  {:type "html", :content "<pre> Details </pre>"}
  {:type "text",
   :content " section of the\nformatter class specification.\n\n"}
  {:type "html", :content "<i>Returns</i>:&nbsp;"}
  {:type "text", :content "A formatted string"}]}

{:doc-fragments
 [{:type "text", :content "Returns a new "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text", :content " composed of copies of the\n"}
  {:type "html", :content "<pre>CharSequence elements</pre> "}
  {:type "text",
   :content " joined together with a copy of the\nspecified "}
  {:type "html", :content "<pre>delimiter</pre> "}
  {:type "text", :content ".\n\n"}
  {:type "html",
   :content
   "<blockquote> For example,\n  <pre> <pre>\n     List<String> strings = List.of(\"Java\", \"is\", \"cool\");\n     String message = String.join(\" \", strings);\n     // message returned is: \"Java is cool\"\n\nSet<String> strings =\n         new LinkedHashSet<>(List.of(\"Java\", \"is\", \"very\", \"cool\"));\n     String message = String.join(\"-\", strings);\n     // message returned is: \"Java-is-very-cool\"\n </pre>  </pre> </blockquote>"}
  {:type "text", :content "\n\nNote that if an individual element is "}
  {:type "html", :content "<pre>null</pre> "}
  {:type "text", :content ", then "}
  {:type "html", :content "<pre>\"null\"</pre> "}
  {:type "text", :content " is added."}],
 :doc-first-sentence-fragments
 [{:type "text", :content "Returns a new "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text", :content " composed of copies of the\n"}
  {:type "html", :content "<pre>CharSequence elements</pre> "}
  {:type "text",
   :content " joined together with a copy of the\nspecified "}
  {:type "html", :content "<pre>delimiter</pre> "}
  {:type "text", :content "."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html",
   :content "<i>Param</i>&nbsp;<pre>delimiter</pre>:&nbsp;"}
  {:type "text",
   :content
   "a sequence of characters that is used to separate each\nof the "}
  {:type "html", :content "<pre>elements</pre> "}
  {:type "text", :content " in the resulting "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text", :content "\n"}
  {:type "html",
   :content "<i>Param</i>&nbsp;<pre>elements</pre>:&nbsp;"}
  {:type "text", :content "an "}
  {:type "html", :content "<pre>Iterable</pre> "}
  {:type "text", :content " that will have its "}
  {:type "html", :content "<pre>elements</pre> "}
  {:type "text", :content "\njoined together.\n\n"}
  {:type "html", :content "<i>Returns</i>:&nbsp;"}
  {:type "text", :content "a new "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text", :content " that is composed from the "}
  {:type "html", :content "<pre>elements</pre> "}
  {:type "text", :content "\nargument\n\n"}
  {:type "html",
   :content
   "<i>Throws</i>:&nbsp;<pre>NullPointerException</pre>:&nbsp;"}
  {:type "text", :content "If "}
  {:type "html", :content "<pre>delimiter</pre> "}
  {:type "text", :content " or "}
  {:type "html", :content "<pre>elements</pre> "}
  {:type "text", :content "\nis "}
  {:type "html", :content "<pre>null</pre> "}]}

{:doc-fragments
 [{:type "text",
   :content "Returns a new String composed of copies of the\n"}
  {:type "html", :content "<pre>CharSequence elements</pre> "}
  {:type "text",
   :content " joined together with a copy of\nthe specified "}
  {:type "html", :content "<pre>delimiter</pre> "}
  {:type "text", :content ".\n\n"}
  {:type "html",
   :content
   "<blockquote> For example,\n  <pre> <pre>\n     String message = String.join(\"-\", \"Java\", \"is\", \"cool\");\n     // message returned is: \"Java-is-cool\"\n </pre>  </pre> </blockquote>"}
  {:type "text", :content "\n\nNote that if an element is null, then "}
  {:type "html", :content "<pre>\"null\"</pre> "}
  {:type "text", :content " is added."}],
 :doc-first-sentence-fragments
 [{:type "text",
   :content "Returns a new String composed of copies of the\n"}
  {:type "html", :content "<pre>CharSequence elements</pre> "}
  {:type "text",
   :content " joined together with a copy of\nthe specified "}
  {:type "html", :content "<pre>delimiter</pre> "}
  {:type "text", :content "."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html",
   :content "<i>Param</i>&nbsp;<pre>delimiter</pre>:&nbsp;"}
  {:type "text",
   :content "the delimiter that separates each element\n\n"}
  {:type "html",
   :content "<i>Param</i>&nbsp;<pre>elements</pre>:&nbsp;"}
  {:type "text", :content "the elements to join together.\n\n"}
  {:type "html", :content "<i>Returns</i>:&nbsp;"}
  {:type "text", :content "a new "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text", :content " that is composed of the "}
  {:type "html", :content "<pre>elements</pre> "}
  {:type "text", :content "\nseparated by the "}
  {:type "html", :content "<pre>delimiter</pre> "}
  {:type "text", :content "\n"}
  {:type "html",
   :content
   "<i>Throws</i>:&nbsp;<pre>NullPointerException</pre>:&nbsp;"}
  {:type "text", :content "If "}
  {:type "html", :content "<pre>delimiter</pre> "}
  {:type "text", :content " or "}
  {:type "html", :content "<pre>elements</pre> "}
  {:type "text", :content "\nis "}
  {:type "html", :content "<pre>null</pre> "}]}

{:doc-fragments
 [{:type "text",
   :content
   "Returns the character (Unicode code point) before the specified\nindex. The index refers to "}
  {:type "html", :content "<pre>char</pre> "}
  {:type "text",
   :content " values\n(Unicode code units) and ranges from "}
  {:type "html", :content "<pre>1</pre> "}
  {:type "text", :content " to "}
  {:type "html", :content "<pre>CharSequence#length()</pre> "}
  {:type "text", :content ".\n\nIf the "}
  {:type "html", :content "<pre>char</pre> "}
  {:type "text", :content " value at "}
  {:type "html", :content "<pre>(index - 1)</pre> "}
  {:type "text", :content "\nis in the low-surrogate range, "}
  {:type "html", :content "<pre>(index - 2)</pre> "}
  {:type "text", :content " is not\nnegative, and the "}
  {:type "html", :content "<pre>char</pre> "}
  {:type "text", :content " value at "}
  {:type "html", :content "<pre>(index -\n 2)</pre> "}
  {:type "text",
   :content
   " is in the high-surrogate range, then the\nsupplementary code point value of the surrogate pair is\nreturned. If the "}
  {:type "html", :content "<pre>char</pre> "}
  {:type "text", :content " value at "}
  {:type "html", :content "<pre>index -\n 1</pre> "}
  {:type "text",
   :content
   " is an unpaired low-surrogate or a high-surrogate, the\nsurrogate value is returned."}],
 :doc-first-sentence-fragments
 [{:type "text",
   :content
   "Returns the character (Unicode code point) before the specified\nindex."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>index</pre>:&nbsp;"}
  {:type "text",
   :content
   "the index following the code point that should be returned\n\n"}
  {:type "html", :content "<i>Returns</i>:&nbsp;"}
  {:type "text",
   :content "the Unicode code point value before the given index.\n\n"}
  {:type "html",
   :content
   "<i>Throws</i>:&nbsp;<pre>IndexOutOfBoundsException</pre>:&nbsp;"}
  {:type "text", :content "if the "}
  {:type "html", :content "<pre>index</pre> "}
  {:type "text",
   :content
   "\nargument is less than 1 or greater than the length\nof this string."}]}

{:doc-fragments
 [{:type "text",
   :content
   "Returns a stream of code point values from this sequence.  Any surrogate\npairs encountered in the sequence are combined as if by "}
  {:type "html", :content "<pre>Character#toCodePoint</pre> "}
  {:type "text",
   :content
   " and the result is passed\nto the stream. Any other code units, including ordinary BMP characters,\nunpaired surrogates, and undefined code units, are zero-extended to\n"}
  {:type "html", :content "<pre>int</pre> "}
  {:type "text",
   :content " values which are then passed to the stream."}],
 :doc-first-sentence-fragments
 [{:type "text",
   :content
   "Returns a stream of code point values from this sequence."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html", :content "<i>Returns</i>:&nbsp;"}
  {:type "text",
   :content "an IntStream of Unicode code points from this sequence"}]}

{:doc-fragments
 [{:type "text",
   :content
   "Code shared by String and AbstractStringBuilder to do searches. The\nsource is the character array being searched, and the target\nis the string being searched for."}],
 :doc-first-sentence-fragments
 [{:type "text",
   :content
   "Code shared by String and AbstractStringBuilder to do searches."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>src</pre>:&nbsp;"}
  {:type "text", :content "the characters being searched.\n\n"}
  {:type "html",
   :content "<i>Param</i>&nbsp;<pre>srcCoder</pre>:&nbsp;"}
  {:type "text", :content "the coder of the source string.\n\n"}
  {:type "html",
   :content "<i>Param</i>&nbsp;<pre>srcCount</pre>:&nbsp;"}
  {:type "text", :content "length of the source string.\n\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>tgtStr</pre>:&nbsp;"}
  {:type "text", :content "the characters being searched for.\n\n"}
  {:type "html",
   :content "<i>Param</i>&nbsp;<pre>fromIndex</pre>:&nbsp;"}
  {:type "text", :content "the index to begin searching from."}]}

{:doc-fragments
 [{:type "text",
   :content
   "Returns the index within this string of the first occurrence of the\nspecified substring, starting at the specified index.\n\nThe returned index is the smallest value "}
  {:type "html", :content "<pre>k</pre> "}
  {:type "text", :content " for which:\n"}
  {:type "html",
   :content
   "<pre> <pre>\n     k >= Math.min(fromIndex, this.length()) &&\n                   this.startsWith(str, k)\n </pre>  </pre>"}
  {:type "text", :content "\nIf no such value of "}
  {:type "html", :content "<pre>k</pre> "}
  {:type "text", :content " exists, then "}
  {:type "html", :content "<pre>-1</pre> "}
  {:type "text", :content " is returned."}],
 :doc-first-sentence-fragments
 [{:type "text",
   :content
   "Returns the index within this string of the first occurrence of the\nspecified substring, starting at the specified index."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>str</pre>:&nbsp;"}
  {:type "text", :content "the substring to search for.\n\n"}
  {:type "html",
   :content "<i>Param</i>&nbsp;<pre>fromIndex</pre>:&nbsp;"}
  {:type "text",
   :content "the index from which to start the search.\n\n"}
  {:type "html", :content "<i>Returns</i>:&nbsp;"}
  {:type "text",
   :content
   "the index of the first occurrence of the specified substring,\nstarting at the specified index,\nor "}
  {:type "html", :content "<pre>-1</pre> "}
  {:type "text", :content " if there is no such occurrence."}]}

{:doc-fragments
 [{:type "text",
   :content
   "Returns the index within this string of the first occurrence of the\nspecified substring.\n\nThe returned index is the smallest value "}
  {:type "html", :content "<pre>k</pre> "}
  {:type "text", :content " for which:\n"}
  {:type "html",
   :content "<pre> <pre>\n this.startsWith(str, k)\n </pre>  </pre>"}
  {:type "text", :content "\nIf no such value of "}
  {:type "html", :content "<pre>k</pre> "}
  {:type "text", :content " exists, then "}
  {:type "html", :content "<pre>-1</pre> "}
  {:type "text", :content " is returned."}],
 :doc-first-sentence-fragments
 [{:type "text",
   :content
   "Returns the index within this string of the first occurrence of the\nspecified substring."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>str</pre>:&nbsp;"}
  {:type "text", :content "the substring to search for.\n\n"}
  {:type "html", :content "<i>Returns</i>:&nbsp;"}
  {:type "text",
   :content
   "the index of the first occurrence of the specified substring,\nor "}
  {:type "html", :content "<pre>-1</pre> "}
  {:type "text", :content " if there is no such occurrence."}]}

{:doc-fragments
 [{:type "text",
   :content
   "Returns the index within this string of the first occurrence of the\nspecified character, starting the search at the specified index.\n\nIf a character with value "}
  {:type "html", :content "<pre>ch</pre> "}
  {:type "text",
   :content " occurs in the\ncharacter sequence represented by this "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text", :content "\nobject at an index no smaller than "}
  {:type "html", :content "<pre>fromIndex</pre> "}
  {:type "text",
   :content
   ", then\nthe index of the first such occurrence is returned. For values\nof "}
  {:type "html", :content "<pre>ch</pre> "}
  {:type "text",
   :content
   " in the range from 0 to 0xFFFF (inclusive),\nthis is the smallest value "}
  {:type "html", :content "<i> k </i>"}
  {:type "text", :content " such that:\n"}
  {:type "html",
   :content
   "<blockquote> <pre> \n (this.charAt( <i> k </i> ) == ch)  <pre>&&</pre>   ( <i> k </i>   &gt; = fromIndex)\n  </pre> </blockquote>"}
  {:type "text", :content "\nis true. For other values of "}
  {:type "html", :content "<pre>ch</pre> "}
  {:type "text", :content ", it is the\nsmallest value "}
  {:type "html", :content "<i> k </i>"}
  {:type "text", :content " such that:\n"}
  {:type "html",
   :content
   "<blockquote> <pre> \n (this.codePointAt( <i> k </i> ) == ch)  <pre>&&</pre>   ( <i> k </i>   &gt; = fromIndex)\n  </pre> </blockquote>"}
  {:type "text",
   :content
   "\nis true. In either case, if no such character occurs in this\nstring at or after position "}
  {:type "html", :content "<pre>fromIndex</pre> "}
  {:type "text", :content ", then\n"}
  {:type "html", :content "<pre>-1</pre> "}
  {:type "text",
   :content
   " is returned.\n\nThere is no restriction on the value of "}
  {:type "html", :content "<pre>fromIndex</pre> "}
  {:type "text",
   :content
   ". If it\nis negative, it has the same effect as if it were zero: this entire\nstring may be searched. If it is greater than the length of this\nstring, it has the same effect as if it were equal to the length of\nthis string: "}
  {:type "html", :content "<pre>-1</pre> "}
  {:type "text",
   :content " is returned.\n\nAll indices are specified in "}
  {:type "html", :content "<pre>char</pre> "}
  {:type "text", :content " values\n(Unicode code units)."}],
 :doc-first-sentence-fragments
 [{:type "text",
   :content
   "Returns the index within this string of the first occurrence of the\nspecified character, starting the search at the specified index."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>ch</pre>:&nbsp;"}
  {:type "text", :content "a character (Unicode code point).\n\n"}
  {:type "html",
   :content "<i>Param</i>&nbsp;<pre>fromIndex</pre>:&nbsp;"}
  {:type "text", :content "the index to start the search from.\n\n"}
  {:type "html", :content "<i>Returns</i>:&nbsp;"}
  {:type "text",
   :content
   "the index of the first occurrence of the character in the\ncharacter sequence represented by this object that is greater\nthan or equal to "}
  {:type "html", :content "<pre>fromIndex</pre> "}
  {:type "text", :content ", or "}
  {:type "html", :content "<pre>-1</pre> "}
  {:type "text", :content "\nif the character does not occur."}]}

{:doc-fragments
 [{:type "text",
   :content
   "Returns the index within this string of the first occurrence of\nthe specified character. If a character with value\n"}
  {:type "html", :content "<pre>ch</pre> "}
  {:type "text",
   :content " occurs in the character sequence represented by\nthis "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text",
   :content
   " object, then the index (in Unicode\ncode units) of the first such occurrence is returned. For\nvalues of "}
  {:type "html", :content "<pre>ch</pre> "}
  {:type "text",
   :content
   " in the range from 0 to 0xFFFF\n(inclusive), this is the smallest value "}
  {:type "html", :content "<i> k </i>"}
  {:type "text", :content " such that:\n"}
  {:type "html",
   :content
   "<blockquote> <pre> \n this.charAt( <i> k </i> ) == ch\n  </pre> </blockquote>"}
  {:type "text", :content "\nis true. For other values of "}
  {:type "html", :content "<pre>ch</pre> "}
  {:type "text", :content ", it is the\nsmallest value "}
  {:type "html", :content "<i> k </i>"}
  {:type "text", :content " such that:\n"}
  {:type "html",
   :content
   "<blockquote> <pre> \n this.codePointAt( <i> k </i> ) == ch\n  </pre> </blockquote>"}
  {:type "text",
   :content
   "\nis true. In either case, if no such character occurs in this\nstring, then "}
  {:type "html", :content "<pre>-1</pre> "}
  {:type "text", :content " is returned."}],
 :doc-first-sentence-fragments
 [{:type "text",
   :content
   "Returns the index within this string of the first occurrence of\nthe specified character."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>ch</pre>:&nbsp;"}
  {:type "text", :content "a character (Unicode code point).\n\n"}
  {:type "html", :content "<i>Returns</i>:&nbsp;"}
  {:type "text",
   :content
   "the index of the first occurrence of the character in the\ncharacter sequence represented by this object, or\n"}
  {:type "html", :content "<pre>-1</pre> "}
  {:type "text", :content " if the character does not occur."}]}

{:doc-fragments
 [{:type "text",
   :content
   "Copy character bytes from this string into dst starting at dstBegin.\nThis method doesn't perform any range checking.\n\nInvoker guarantees: dst is in UTF16 (inflate itself for asb), if two\ncoders are different, and dst is big enough (range check)"}],
 :doc-first-sentence-fragments
 [{:type "text",
   :content
   "Copy character bytes from this string into dst starting at dstBegin."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>srcPos</pre>:&nbsp;"}
  {:type "text", :content "the char index, not offset of byte[]\n\n"}
  {:type "html",
   :content "<i>Param</i>&nbsp;<pre>dstBegin</pre>:&nbsp;"}
  {:type "text", :content "the char index to start from\n\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>coder</pre>:&nbsp;"}
  {:type "text", :content "the coder of dst[]\n\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>length</pre>:&nbsp;"}
  {:type "text", :content "the amount of copied chars"}]}

{:doc-fragments
 [{:type "text",
   :content
   "Copy character bytes from this string into dst starting at dstBegin.\nThis method doesn't perform any range checking.\n\nInvoker guarantees: dst is in UTF16 (inflate itself for asb), if two\ncoders are different, and dst is big enough (range check)"}],
 :doc-first-sentence-fragments
 [{:type "text",
   :content
   "Copy character bytes from this string into dst starting at dstBegin."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html",
   :content "<i>Param</i>&nbsp;<pre>dstBegin</pre>:&nbsp;"}
  {:type "text", :content "the char index, not offset of byte[]\n\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>coder</pre>:&nbsp;"}
  {:type "text", :content "the coder of dst[]"}]}

{:doc-fragments
 [{:type "text", :content "Encodes this "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text",
   :content
   " into a sequence of bytes using the\nplatform's default charset, storing the result into a new byte array.\n\nThe behavior of this method when this string cannot be encoded in\nthe default charset is unspecified.  The "}
  {:type "html",
   :content "<pre>java.nio.charset.CharsetEncoder</pre> "}
  {:type "text",
   :content
   " class should be used when more control\nover the encoding process is required."}],
 :doc-first-sentence-fragments
 [{:type "text", :content "Encodes this "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text",
   :content
   " into a sequence of bytes using the\nplatform's default charset, storing the result into a new byte array."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html", :content "<i>Returns</i>:&nbsp;"}
  {:type "text", :content "The resultant byte array"}]}

{:doc-fragments
 [{:type "text", :content "Encodes this "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text",
   :content " into a sequence of bytes using the given\n"}
  {:type "html", :content "<pre>java.nio.charset.Charset</pre> "}
  {:type "text",
   :content
   ", storing the result into a\nnew byte array.\n\nThis method always replaces malformed-input and unmappable-character\nsequences with this charset's default replacement byte array.  The\n"}
  {:type "html",
   :content "<pre>java.nio.charset.CharsetEncoder</pre> "}
  {:type "text",
   :content
   " class should be used when more\ncontrol over the encoding process is required."}],
 :doc-first-sentence-fragments
 [{:type "text", :content "Encodes this "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text",
   :content " into a sequence of bytes using the given\n"}
  {:type "html", :content "<pre>java.nio.charset.Charset</pre> "}
  {:type "text",
   :content ", storing the result into a\nnew byte array."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html",
   :content "<i>Param</i>&nbsp;<pre>charset</pre>:&nbsp;"}
  {:type "text", :content "The "}
  {:type "html", :content "<pre>java.nio.charset.Charset</pre> "}
  {:type "text", :content " to be used to encode\nthe "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text", :content "\n"}
  {:type "html", :content "<i>Returns</i>:&nbsp;"}
  {:type "text", :content "The resultant byte array"}]}

{:doc-fragments
 [{:type "text", :content "Encodes this "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text",
   :content
   " into a sequence of bytes using the named\ncharset, storing the result into a new byte array.\n\nThe behavior of this method when this string cannot be encoded in\nthe given charset is unspecified.  The "}
  {:type "html",
   :content "<pre>java.nio.charset.CharsetEncoder</pre> "}
  {:type "text",
   :content
   " class should be used when more control\nover the encoding process is required."}],
 :doc-first-sentence-fragments
 [{:type "text", :content "Encodes this "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text",
   :content
   " into a sequence of bytes using the named\ncharset, storing the result into a new byte array."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html",
   :content "<i>Param</i>&nbsp;<pre>charsetName</pre>:&nbsp;"}
  {:type "text", :content "The name of a supported "}
  {:type "html", :content "<pre>java.nio.charset.Charset</pre> "}
  {:type "text", :content "\n"}
  {:type "html", :content "<i>Returns</i>:&nbsp;"}
  {:type "text", :content "The resultant byte array\n\n"}
  {:type "html",
   :content
   "<i>Throws</i>:&nbsp;<pre>UnsupportedEncodingException</pre>:&nbsp;"}
  {:type "text", :content "If the named charset is not supported"}]}

{:doc-fragments
 [{:type "text",
   :content
   "Copies characters from this string into the destination byte array. Each\nbyte receives the 8 low-order bits of the corresponding character. The\neight high-order bits of each character are not copied and do not\nparticipate in the transfer in any way.\n\nThe first character to be copied is at index "}
  {:type "html", :content "<pre>srcBegin</pre> "}
  {:type "text",
   :content "; the\nlast character to be copied is at index "}
  {:type "html", :content "<pre>srcEnd-1</pre> "}
  {:type "text",
   :content ".  The total\nnumber of characters to be copied is "}
  {:type "html", :content "<pre>srcEnd-srcBegin</pre> "}
  {:type "text",
   :content
   ". The\ncharacters, converted to bytes, are copied into the subarray of "}
  {:type "html", :content "<pre>\n dst</pre> "}
  {:type "text", :content " starting at index "}
  {:type "html", :content "<pre>dstBegin</pre> "}
  {:type "text", :content " and ending at index:\n\n"}
  {:type "html",
   :content
   "<blockquote> <pre> \n     dstBegin + (srcEnd-srcBegin) - 1\n  </pre> </blockquote>"}],
 :doc-first-sentence-fragments
 [{:type "text",
   :content
   "Copies characters from this string into the destination byte array."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html",
   :content "<i>Param</i>&nbsp;<pre>srcBegin</pre>:&nbsp;"}
  {:type "text",
   :content "Index of the first character in the string to copy\n\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>srcEnd</pre>:&nbsp;"}
  {:type "text",
   :content "Index after the last character in the string to copy\n\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>dst</pre>:&nbsp;"}
  {:type "text", :content "The destination array\n\n"}
  {:type "html",
   :content "<i>Param</i>&nbsp;<pre>dstBegin</pre>:&nbsp;"}
  {:type "text",
   :content "The start offset in the destination array\n\n"}
  {:type "html",
   :content
   "<i>Throws</i>:&nbsp;<pre>IndexOutOfBoundsException</pre>:&nbsp;"}
  {:type "text", :content "If any of the following is true:\n"}
  {:type "html",
   :content
   "<ul> \n             <li>   <pre>srcBegin</pre>   is negative\n             <li>   <pre>srcBegin</pre>   is greater than  <pre>srcEnd</pre>  \n             <li>   <pre>srcEnd</pre>   is greater than the length of this String\n             <li>   <pre>dstBegin</pre>   is negative\n             <li>   <pre>dstBegin+(srcEnd-srcBegin)</pre>   is larger than  <pre>\n                 dst.length</pre>  \n           </ul>"}]}

{:doc-fragments
 [{:type "text",
   :content
   "Code shared by String and AbstractStringBuilder to do searches. The\nsource is the character array being searched, and the target\nis the string being searched for."}],
 :doc-first-sentence-fragments
 [{:type "text",
   :content
   "Code shared by String and AbstractStringBuilder to do searches."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>src</pre>:&nbsp;"}
  {:type "text", :content "the characters being searched.\n\n"}
  {:type "html",
   :content "<i>Param</i>&nbsp;<pre>srcCoder</pre>:&nbsp;"}
  {:type "text",
   :content "coder handles the mapping between bytes/chars\n\n"}
  {:type "html",
   :content "<i>Param</i>&nbsp;<pre>srcCount</pre>:&nbsp;"}
  {:type "text", :content "count of the source string.\n\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>tgtStr</pre>:&nbsp;"}
  {:type "text", :content "the characters being searched for.\n\n"}
  {:type "html",
   :content "<i>Param</i>&nbsp;<pre>fromIndex</pre>:&nbsp;"}
  {:type "text", :content "the index to begin searching from."}]}

{:doc-fragments
 [{:type "text",
   :content
   "Returns the index within this string of the last occurrence of the\nspecified substring, searching backward starting at the specified index.\n\nThe returned index is the largest value "}
  {:type "html", :content "<pre>k</pre> "}
  {:type "text", :content " for which:\n"}
  {:type "html",
   :content
   "<pre> <pre>\n     k <= Math.min(fromIndex, this.length()) &&\n                   this.startsWith(str, k)\n </pre>  </pre>"}
  {:type "text", :content "\nIf no such value of "}
  {:type "html", :content "<pre>k</pre> "}
  {:type "text", :content " exists, then "}
  {:type "html", :content "<pre>-1</pre> "}
  {:type "text", :content " is returned."}],
 :doc-first-sentence-fragments
 [{:type "text",
   :content
   "Returns the index within this string of the last occurrence of the\nspecified substring, searching backward starting at the specified index."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>str</pre>:&nbsp;"}
  {:type "text", :content "the substring to search for.\n\n"}
  {:type "html",
   :content "<i>Param</i>&nbsp;<pre>fromIndex</pre>:&nbsp;"}
  {:type "text", :content "the index to start the search from.\n\n"}
  {:type "html", :content "<i>Returns</i>:&nbsp;"}
  {:type "text",
   :content
   "the index of the last occurrence of the specified substring,\nsearching backward from the specified index,\nor "}
  {:type "html", :content "<pre>-1</pre> "}
  {:type "text", :content " if there is no such occurrence."}]}

{:doc-fragments
 [{:type "text",
   :content
   "Returns the index within this string of the last occurrence of the\nspecified substring.  The last occurrence of the empty string \"\"\nis considered to occur at the index value "}
  {:type "html", :content "<pre>this.length()</pre> "}
  {:type "text",
   :content ".\n\nThe returned index is the largest value "}
  {:type "html", :content "<pre>k</pre> "}
  {:type "text", :content " for which:\n"}
  {:type "html",
   :content "<pre> <pre>\n this.startsWith(str, k)\n </pre>  </pre>"}
  {:type "text", :content "\nIf no such value of "}
  {:type "html", :content "<pre>k</pre> "}
  {:type "text", :content " exists, then "}
  {:type "html", :content "<pre>-1</pre> "}
  {:type "text", :content " is returned."}],
 :doc-first-sentence-fragments
 [{:type "text",
   :content
   "Returns the index within this string of the last occurrence of the\nspecified substring."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>str</pre>:&nbsp;"}
  {:type "text", :content "the substring to search for.\n\n"}
  {:type "html", :content "<i>Returns</i>:&nbsp;"}
  {:type "text",
   :content
   "the index of the last occurrence of the specified substring,\nor "}
  {:type "html", :content "<pre>-1</pre> "}
  {:type "text", :content " if there is no such occurrence."}]}

{:doc-fragments
 [{:type "text",
   :content
   "Returns the index within this string of the last occurrence of\nthe specified character, searching backward starting at the\nspecified index. For values of "}
  {:type "html", :content "<pre>ch</pre> "}
  {:type "text",
   :content
   " in the range\nfrom 0 to 0xFFFF (inclusive), the index returned is the largest\nvalue "}
  {:type "html", :content "<i> k </i>"}
  {:type "text", :content " such that:\n"}
  {:type "html",
   :content
   "<blockquote> <pre> \n (this.charAt( <i> k </i> ) == ch)  <pre>&&</pre>   ( <i> k </i>   &lt; = fromIndex)\n  </pre> </blockquote>"}
  {:type "text", :content "\nis true. For other values of "}
  {:type "html", :content "<pre>ch</pre> "}
  {:type "text", :content ", it is the\nlargest value "}
  {:type "html", :content "<i> k </i>"}
  {:type "text", :content " such that:\n"}
  {:type "html",
   :content
   "<blockquote> <pre> \n (this.codePointAt( <i> k </i> ) == ch)  <pre>&&</pre>   ( <i> k </i>   &lt; = fromIndex)\n  </pre> </blockquote>"}
  {:type "text",
   :content
   "\nis true. In either case, if no such character occurs in this\nstring at or before position "}
  {:type "html", :content "<pre>fromIndex</pre> "}
  {:type "text", :content ", then\n"}
  {:type "html", :content "<pre>-1</pre> "}
  {:type "text",
   :content " is returned.\n\nAll indices are specified in "}
  {:type "html", :content "<pre>char</pre> "}
  {:type "text", :content " values\n(Unicode code units)."}],
 :doc-first-sentence-fragments
 [{:type "text",
   :content
   "Returns the index within this string of the last occurrence of\nthe specified character, searching backward starting at the\nspecified index."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>ch</pre>:&nbsp;"}
  {:type "text", :content "a character (Unicode code point).\n\n"}
  {:type "html",
   :content "<i>Param</i>&nbsp;<pre>fromIndex</pre>:&nbsp;"}
  {:type "text",
   :content
   "the index to start the search from. There is no\nrestriction on the value of "}
  {:type "html", :content "<pre>fromIndex</pre> "}
  {:type "text",
   :content
   ". If it is\ngreater than or equal to the length of this string, it has\nthe same effect as if it were equal to one less than the\nlength of this string: this entire string may be searched.\nIf it is negative, it has the same effect as if it were -1:\n-1 is returned.\n\n"}
  {:type "html", :content "<i>Returns</i>:&nbsp;"}
  {:type "text",
   :content
   "the index of the last occurrence of the character in the\ncharacter sequence represented by this object that is less\nthan or equal to "}
  {:type "html", :content "<pre>fromIndex</pre> "}
  {:type "text", :content ", or "}
  {:type "html", :content "<pre>-1</pre> "}
  {:type "text",
   :content "\nif the character does not occur before that point."}]}

{:doc-fragments
 [{:type "text",
   :content
   "Returns the index within this string of the last occurrence of\nthe specified character. For values of "}
  {:type "html", :content "<pre>ch</pre> "}
  {:type "text",
   :content
   " in the\nrange from 0 to 0xFFFF (inclusive), the index (in Unicode code\nunits) returned is the largest value "}
  {:type "html", :content "<i> k </i>"}
  {:type "text", :content " such that:\n"}
  {:type "html",
   :content
   "<blockquote> <pre> \n this.charAt( <i> k </i> ) == ch\n  </pre> </blockquote>"}
  {:type "text", :content "\nis true. For other values of "}
  {:type "html", :content "<pre>ch</pre> "}
  {:type "text", :content ", it is the\nlargest value "}
  {:type "html", :content "<i> k </i>"}
  {:type "text", :content " such that:\n"}
  {:type "html",
   :content
   "<blockquote> <pre> \n this.codePointAt( <i> k </i> ) == ch\n  </pre> </blockquote>"}
  {:type "text",
   :content
   "\nis true.  In either case, if no such character occurs in this\nstring, then "}
  {:type "html", :content "<pre>-1</pre> "}
  {:type "text", :content " is returned.  The\n"}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text",
   :content
   " is searched backwards starting at the last\ncharacter."}],
 :doc-first-sentence-fragments
 [{:type "text",
   :content
   "Returns the index within this string of the last occurrence of\nthe specified character."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>ch</pre>:&nbsp;"}
  {:type "text", :content "a character (Unicode code point).\n\n"}
  {:type "html", :content "<i>Returns</i>:&nbsp;"}
  {:type "text",
   :content
   "the index of the last occurrence of the character in the\ncharacter sequence represented by this object, or\n"}
  {:type "html", :content "<pre>-1</pre> "}
  {:type "text", :content " if the character does not occur."}]}

{:doc-fragments
 [{:type "text", :content "Returns the "}
  {:type "html", :content "<pre>char</pre> "}
  {:type "text",
   :content " value at the\nspecified index. An index ranges from "}
  {:type "html", :content "<pre>0</pre> "}
  {:type "text", :content " to\n"}
  {:type "html", :content "<pre>length() - 1</pre> "}
  {:type "text", :content ". The first "}
  {:type "html", :content "<pre>char</pre> "}
  {:type "text", :content " value of the sequence\nis at index "}
  {:type "html", :content "<pre>0</pre> "}
  {:type "text", :content ", the next at index "}
  {:type "html", :content "<pre>1</pre> "}
  {:type "text",
   :content ",\nand so on, as for array indexing.\n\nIf the "}
  {:type "html", :content "<pre>char</pre> "}
  {:type "text", :content " value specified by the index is a\n"}
  {:type "html", :content "<pre> surrogate </pre>"}
  {:type "text", :content ", the surrogate\nvalue is returned."}],
 :doc-first-sentence-fragments
 [{:type "text", :content "Returns the "}
  {:type "html", :content "<pre>char</pre> "}
  {:type "text", :content " value at the\nspecified index."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html", :content "<i>Param</i>&nbsp;<pre>index</pre>:&nbsp;"}
  {:type "text", :content "the index of the "}
  {:type "html", :content "<pre>char</pre> "}
  {:type "text", :content " value.\n\n"}
  {:type "html", :content "<i>Returns</i>:&nbsp;"}
  {:type "text", :content "the "}
  {:type "html", :content "<pre>char</pre> "}
  {:type "text",
   :content
   " value at the specified index of this string.\nThe first "}
  {:type "html", :content "<pre>char</pre> "}
  {:type "text", :content " value is at index "}
  {:type "html", :content "<pre>0</pre> "}
  {:type "text", :content ".\n\n"}
  {:type "html",
   :content
   "<i>Throws</i>:&nbsp;<pre>IndexOutOfBoundsException</pre>:&nbsp;"}
  {:type "text", :content "if the "}
  {:type "html", :content "<pre>index</pre> "}
  {:type "text",
   :content
   "\nargument is negative or not less than the length of this\nstring."}]}

{:doc-fragments
 [{:type "text", :content "Returns "}
  {:type "html", :content "<pre>true</pre> "}
  {:type "text", :content " if the string is empty or contains only\n"}
  {:type "html", :content "<pre>Character#isWhitespace(int)</pre> "}
  {:type "text", :content " codepoints,\notherwise "}
  {:type "html", :content "<pre>false</pre> "}
  {:type "text", :content "."}],
 :doc-first-sentence-fragments
 [{:type "text", :content "Returns "}
  {:type "html", :content "<pre>true</pre> "}
  {:type "text", :content " if the string is empty or contains only\n"}
  {:type "html", :content "<pre>Character#isWhitespace(int)</pre> "}
  {:type "text", :content " codepoints,\notherwise "}
  {:type "html", :content "<pre>false</pre> "}
  {:type "text", :content "."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html", :content "<i>Returns</i>:&nbsp; <pre>true</pre> "}
  {:type "text", :content " if the string is empty or contains only\n"}
  {:type "html", :content "<pre>Character#isWhitespace(int)</pre> "}
  {:type "text", :content " codepoints,\notherwise "}
  {:type "html", :content "<pre>false</pre> "}]}

{:doc-fragments
 [{:type "text",
   :content
   "The identifier of the encoding used to encode the bytes in\n"}
  {:type "html", :content "<pre>value</pre> "}
  {:type "text",
   :content
   ". The supported values in this implementation are\n\nLATIN1\nUTF16"}],
 :doc-first-sentence-fragments
 [{:type "text",
   :content
   "The identifier of the encoding used to encode the bytes in\n"}
  {:type "html", :content "<pre>value</pre> "}
  {:type "text", :content "."}],
 :doc-block-tags-fragments []}

{:doc-fragments
 [{:type "text",
   :content
   "Compares two strings lexicographically.\nThe comparison is based on the Unicode value of each character in\nthe strings. The character sequence represented by this\n"}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text",
   :content
   " object is compared lexicographically to the\ncharacter sequence represented by the argument string. The result is\na negative integer if this "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text",
   :content
   " object\nlexicographically precedes the argument string. The result is a\npositive integer if this "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text",
   :content
   " object lexicographically\nfollows the argument string. The result is zero if the strings\nare equal; "}
  {:type "html", :content "<pre>compareTo</pre> "}
  {:type "text", :content " returns "}
  {:type "html", :content "<pre>0</pre> "}
  {:type "text", :content " exactly when\nthe "}
  {:type "html", :content "<pre>#equals(Object)</pre> "}
  {:type "text", :content " method would return "}
  {:type "html", :content "<pre>true</pre> "}
  {:type "text",
   :content
   ".\n\nThis is the definition of lexicographic ordering. If two strings are\ndifferent, then either they have different characters at some index\nthat is a valid index for both strings, or their lengths are different,\nor both. If they have different characters at one or more index\npositions, let "}
  {:type "html", :content "<i> k </i>"}
  {:type "text",
   :content
   " be the smallest such index; then the string\nwhose character at position "}
  {:type "html", :content "<i> k </i>"}
  {:type "text",
   :content " has the smaller value, as\ndetermined by using the "}
  {:type "html", :content "<pre><</pre> "}
  {:type "text",
   :content
   " operator, lexicographically precedes the\nother string. In this case, "}
  {:type "html", :content "<pre>compareTo</pre> "}
  {:type "text",
   :content
   " returns the\ndifference of the two character values at position "}
  {:type "html", :content "<pre>k</pre> "}
  {:type "text",
   :content " in\nthe two string -- that is, the value:\n"}
  {:type "html",
   :content
   "<blockquote> <pre> \n this.charAt(k)-anotherString.charAt(k)\n  </pre> </blockquote>"}
  {:type "text",
   :content
   "\nIf there is no index position at which they differ, then the shorter\nstring lexicographically precedes the longer string. In this case,\n"}
  {:type "html", :content "<pre>compareTo</pre> "}
  {:type "text",
   :content
   " returns the difference of the lengths of the\nstrings -- that is, the value:\n"}
  {:type "html",
   :content
   "<blockquote> <pre> \n this.length()-anotherString.length()\n  </pre> </blockquote>"}
  {:type "text",
   :content "\n\nFor finer-grained String comparison, refer to\n"}
  {:type "html", :content "<pre>java.text.Collator</pre> "}
  {:type "text", :content "."}],
 :doc-first-sentence-fragments
 [{:type "text", :content "Compares two strings lexicographically."}],
 :doc-block-tags-fragments
 [{:type "text", :content "\n"}
  {:type "html",
   :content "<i>Param</i>&nbsp;<pre>anotherString</pre>:&nbsp;"}
  {:type "text", :content "the "}
  {:type "html", :content "<pre>String</pre> "}
  {:type "text", :content " to be compared.\n\n"}
  {:type "html", :content "<i>Returns</i>:&nbsp;"}
  {:type "text", :content "the value "}
  {:type "html", :content "<pre>0</pre> "}
  {:type "text",
   :content
   " if the argument string is equal to\nthis string; a value less than "}
  {:type "html", :content "<pre>0</pre> "}
  {:type "text",
   :content
   " if this string\nis lexicographically less than the string argument; and a\nvalue greater than "}
  {:type "html", :content "<pre>0</pre> "}
  {:type "text",
   :content
   " if this string is\nlexicographically greater than the string argument."}]}

]